package com.hedera.services.bdd.suites.utils.keypairs;

/*-
 * ‌
 * Hedera Services Test Clients
 * ​
 * Copyright (C) 2018 - 2020 Hedera Hashgraph, LLC
 * ​
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ‍
 */

import io.github.novacrypto.bip39.MnemonicGenerator;
import io.github.novacrypto.bip39.MnemonicValidator;
import io.github.novacrypto.bip39.Validation.InvalidChecksumException;
import io.github.novacrypto.bip39.Validation.InvalidWordCountException;
import io.github.novacrypto.bip39.Validation.UnexpectedWhiteSpaceException;
import io.github.novacrypto.bip39.Validation.WordNotFoundException;
import io.github.novacrypto.bip39.wordlists.English;
import org.bouncycastle.crypto.digests.SHA512Digest;
import org.bouncycastle.crypto.generators.PKCS5S2ParametersGenerator;
import org.bouncycastle.crypto.params.KeyParameter;

import javax.annotation.Nullable;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public final class Mnemonic {

	public final List<CharSequence> words;
	public static final String NO_PASSPHRASE = "";

	@Nullable
	private String asString;

	private final static MnemonicGenerator generator = new MnemonicGenerator(English.INSTANCE);

	private static final SecureRandom secureRandom = new SecureRandom();

	public Mnemonic(List<CharSequence> wordList) {
		if (wordList.size() != 24) {
			throw new IllegalArgumentException("wordList must have length 24");
		}

		this.words = Collections.unmodifiableList(wordList);
	}

	public static Mnemonic fromString(String mnemonicString) {
		return new Mnemonic(Arrays.asList(mnemonicString.split(" ")));
	}

	public byte[] toSeed(String passphrase) {
		final String salt = "mnemonic" + passphrase;

		// BIP-39 seed generation
		final PKCS5S2ParametersGenerator pbkdf2 = new PKCS5S2ParametersGenerator(new SHA512Digest());
		pbkdf2.init(
				toString().getBytes(StandardCharsets.UTF_8),
				salt.getBytes(StandardCharsets.UTF_8),
				2048);

		final KeyParameter key = (KeyParameter) pbkdf2.generateDerivedParameters(512);
		return key.getKey();
	}

	public static Mnemonic generate() {
		final byte[] entropy = new byte[32];
		secureRandom.nextBytes(entropy);

		final ArrayList<CharSequence> wordList = new ArrayList<>(24);

		generator.createMnemonic(entropy, word -> {
			// the generator spits out spaces whether you want them or not
			if (!word.toString().equals(" ")) {
				wordList.add(word);
			}
		});

		return new Mnemonic(wordList);
	}

	/**
	 * Recover a private key from this mnemonic phrase.
	 *
	 * @return the recovered key; use {@link Ed25519PrivateKey#derive(int)} to get a key for an
	 * 		account index (0 for default account)
	 * @see Ed25519PrivateKey#fromMnemonic(Mnemonic)
	 */
	public Ed25519PrivateKey toPrivateKey() {
		return toPrivateKey(NO_PASSPHRASE);
	}

	/**
	 * Recover a private key from this mnemonic phrase.
	 *
	 * This is not compatible with the phrases generated by the Android and iOS wallets;
	 * use the no-passphrase version instead.
	 *
	 * @param passphrase
	 * 		the passphrase used to protect the mnemonic (not used in the
	 * 		mobile wallets, use {@link #toPrivateKey()} instead.)
	 * @return the recovered key; use {@link Ed25519PrivateKey#derive(int)} to get a key for an
	 * 		account index (0 for default account)
	 * @see Ed25519PrivateKey#fromMnemonic(Mnemonic, String)
	 */
	public Ed25519PrivateKey toPrivateKey(String passphrase) {
		return Ed25519PrivateKey.fromMnemonic(this, passphrase);
	}

	/**
	 * Recover a private key from this mnemonic phrase.
	 *
	 * This is not compatible with the phrases generated by the Android and iOS wallets;
	 * use the no-passphrase version instead.
	 *
	 * @param index
	 * 		The index of the requested key
	 * @return the recovered key; Use index = 0 to recover the key generated by the wallet
	 * @see Ed25519PrivateKey#fromMnemonic(Mnemonic, String)
	 */
	public Ed25519PrivateKey toPrivateKey(int index) {
		return Ed25519PrivateKey.fromMnemonic(this, index);
	}

	@Override
	public String toString() {
		if (asString == null) {
			asString = String.join(" ", words);
		}

		return asString;
	}

	/***
	 * Stores the mnemonic in a password encrypted file
	 * @param key byte array that contains the key
	 * @param path path to the file where the mnemonic will be stored
	 */
	public void toEncryptedFile(byte[] key, String path) {
		byte[] mnemonicWords = this.toString().getBytes();

		Cipher c;
		FileOutputStream fileOutputStream = null;
		try {
			c = Cipher.getInstance("AES");
			SecretKeySpec k = new SecretKeySpec(key, "AES");
			c.init(Cipher.ENCRYPT_MODE, k);
			byte[] encryptedData = c.doFinal(mnemonicWords);
			File file = new File(path);
			assert !file.isDirectory();
			fileOutputStream = new FileOutputStream(file);
			fileOutputStream.write(encryptedData);
		} catch (Exception e) {
			throw new IllegalArgumentException(e);
		} finally {
			try {
				if (fileOutputStream != null) {
					fileOutputStream.close();
				}
			} catch (IOException e) {
				throw new IllegalStateException(e);
			}
		}
	}

	/***
	 * Loads a mnemonic from a password protected file
	 * @param key byte array where the key is stored
	 * @param path path of the file where the mnemonic is stored
	 */
	public static Mnemonic fromEncryptedFile(byte[] key, String path) {
		FileInputStream fileInputStream = null;
		try {
			File file = new File(path);
			fileInputStream = new FileInputStream(file);
			byte[] encryptedMnemonic = new byte[(int) file.length()];
			fileInputStream.read(encryptedMnemonic);
			Cipher c = Cipher.getInstance("AES");
			SecretKeySpec k = new SecretKeySpec(key, "AES");
			c.init(Cipher.DECRYPT_MODE, k);
			byte[] data = c.doFinal(encryptedMnemonic);
			String decryptedWords = new String(data);
			return fromString(decryptedWords);
		} catch (Exception e) {
			throw new IllegalArgumentException(e);
		} finally {
			try {
				if (fileInputStream != null) {
					fileInputStream.close();
				}
			} catch (IOException e) {
				throw new IllegalStateException(e);
			}
		}
	}

	public boolean validate() {
		try {
			MnemonicValidator.ofWordList(English.INSTANCE).validate(words);
		} catch (InvalidChecksumException | UnexpectedWhiteSpaceException | InvalidWordCountException | WordNotFoundException e) {
			return false;
		}
		return true;
	}

}
