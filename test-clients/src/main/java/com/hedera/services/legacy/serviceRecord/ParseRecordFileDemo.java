package com.hedera.services.legacy.serviceRecord;

/*-
 * ‌
 * Hedera Services Test Clients
 * ​
 * Copyright (C) 2018 - 2020 Hedera Hashgraph, LLC
 * ​
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ‍
 */


import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.stream.Collectors;


import com.hederahashgraph.api.proto.java.Transaction;
import com.hederahashgraph.api.proto.java.TransactionRecord;
import org.apache.commons.codec.binary.Hex;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.Marker;
import org.apache.logging.log4j.MarkerManager;


/**
 * This is a utility file to read back service record file generated by Hedera node
 */
public class ParseRecordFileDemo {

	private static final Logger log = LogManager.getLogger();
	private static final Marker MARKER = MarkerManager.getMarker("SERVICE_RECORD");


	static final Marker LOGM_EXCEPTION = MarkerManager.getMarker("EXCEPTION");

	static final byte TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files
	static final byte TYPE_RECORD = 2;          // next data type is transaction and its record
	static final byte TYPE_SIGNATURE = 3;       // the file content signature, should not be hashed


	/**
	 * Calculate SHA384 hash of a binary file
	 *
	 * @param fileName
	 * 		file name
	 * @return byte array of hash value
	 */
	static private byte[] getFileHash(String fileName) {
		MessageDigest md;
		try {
			md = MessageDigest.getInstance("SHA-384");

			byte[] array = new byte[0];
			try {
				array = Files.readAllBytes(Paths.get(fileName));
			} catch (IOException e) {
				log.error("Exception ", e);
			}
			byte[] fileHash = md.digest(array);
			log.info("File {} Hash = " + Hex.encodeHexString(fileHash));
			return fileHash;

		} catch (NoSuchAlgorithmException e) {
			log.error(LOGM_EXCEPTION, "Exception ", e);
			return null;
		}
	}

	/**
	 * read and parse a list of record files
	 */
	static public void loadRecordFiles(List<String> fileNames) {

		byte[] calculatedPrevHash = null;
		for (String name : fileNames) {
			Pair<byte[], List<Pair<Transaction, TransactionRecord>>> result = loadRecordFile(name);
			byte[] readPrevHash = result.getKey();
			if (calculatedPrevHash != null) {
				if (!Arrays.equals(calculatedPrevHash, readPrevHash)) {

					log.error(LOGM_EXCEPTION, "calculatedPrevHash " + Hex.encodeHexString(calculatedPrevHash));
					log.error(LOGM_EXCEPTION, "readPrevHash       " + Hex.encodeHexString(readPrevHash));
					log.error(LOGM_EXCEPTION, "Error Exception, hash does not match ");

				}
			}
			byte[] thisFileHash = getFileHash(name);
			calculatedPrevHash = thisFileHash;

			log.info("\n\n-----------------");
		}
	}


	/**
	 * Given a service record name, read and parse and return as a list of service record pair
	 *
	 * @param fileName
	 * 		the name of record file to read
	 * @return return previous file hash and list of transaction and record pairs
	 */
	static public Pair<byte[], List<Pair<Transaction, TransactionRecord>>> loadRecordFile(String fileName) {
		File file = new File(fileName);
		FileInputStream stream = null;
		List<Pair<Transaction, TransactionRecord>> txList = new LinkedList<>();
		byte[] prevFileHash = null;

		if (file.exists() == false) {
			log.info(MARKER, "File does not exist " + fileName);
			return null;
		}

		try {
			int counter = 0;
			stream = new FileInputStream(file);
			DataInputStream dis = new DataInputStream(stream);

			prevFileHash = new byte[48];
			int record_format_version = dis.readInt();
			int version = dis.readInt();


			log.info(MARKER, "Record file format version " + record_format_version);
			log.info(MARKER, "HAPI protocol version " + version);

			while (dis.available() != 0) {

				try {
					byte typeDelimiter = dis.readByte();

					switch (typeDelimiter) {
						case TYPE_PREV_HASH:
							dis.read(prevFileHash);
							log.info(MARKER, "Previous file Hash = " + Hex.encodeHexString(prevFileHash));

							break;
						case TYPE_RECORD:
							int byteLength = dis.readInt();
							byte[] rawBytes = new byte[byteLength];

							dis.readFully(rawBytes);
							Transaction transaction = Transaction.parseFrom(rawBytes);

							byteLength = dis.readInt();
							rawBytes = new byte[byteLength];
							dis.readFully(rawBytes);
							TransactionRecord txRecord = TransactionRecord.parseFrom(rawBytes);


							txList.add(Pair.of(transaction, txRecord));

							counter++;
							log.info(MARKER, "record counter = " + counter);
//							log.info(MARKER, "txRecord = " + txRecord);
//							log.info(MARKER, "\n\n-----------------------------");

							break;
						case TYPE_SIGNATURE:
							int sigLength = dis.readInt();
							log.info(MARKER, "sigLength = " + sigLength);
							byte[] sigBytes = new byte[sigLength];
							dis.readFully(sigBytes);
							log.info("File {} Signature = {} ", fileName, Hex.encodeHexString(sigBytes));
							break;

						default:
							log.error(LOGM_EXCEPTION, "Exception Unknown record file delimiter {}", typeDelimiter);
					}


				} catch (Exception e) {
					log.error(LOGM_EXCEPTION, "Exception ", e);
					break;
				}
			}

		} catch (FileNotFoundException e) {
			log.info(MARKER, "File Not Found Error");
		} catch (IOException e) {
			log.info(MARKER, "IOException Error");
		} catch (Exception e) {
			log.info(MARKER, "Parsing Error");
		} finally {
			try {
				if (stream != null)
					stream.close();
			} catch (IOException ex) {
				log.error("Exception in close the stream {}", ex);
			}
		}

		return Pair.of(prevFileHash, txList);
	}

	public static void main(String[] args) throws Exception {

		String pathName = null;
		if (args.length >= 1) {
			pathName = args[0];
			log.info(MARKER, "Given record file name is " + pathName);
		}
		if (pathName != null) {
			File file = new File(pathName);
			if (file.isFile()) {
				log.info(MARKER, "Loading record file {} " + pathName);

				loadRecordFile(pathName);
			} else if (file.isDirectory()) { //if it's a directory

				String[] files = file.list(); // get all files under the directory
				Arrays.sort(files);           // sorted by name (timestamp)

				// add director prefix to get full path
				List<String> fullPaths = Arrays.asList(files).stream()
						.map(s -> file + "/" + s)
						.collect(Collectors.toList());

				log.info(MARKER, "Loading record files from directory {} " + pathName);
				log.info(MARKER, "Files are " + fullPaths);

				loadRecordFiles(fullPaths);
			} else {
				log.error(LOGM_EXCEPTION, "Exception file {} does not exist", pathName);

			}
		} else {
			log.info(MARKER, "No file name is given");
		}
	}
}
