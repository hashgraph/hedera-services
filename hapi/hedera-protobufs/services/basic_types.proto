syntax = "proto3";

package proto;

/*-
 * ‌
 * Hedera Network Services Protobuf
 * ​
 * Copyright (C) 2018 - 2022 Hedera Hashgraph, LLC
 * ​
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ‍
 */

import "timestamp.proto";
import "google/protobuf/wrappers.proto";

option java_package = "com.hederahashgraph.api.proto.java";
// <<<pbj.java_package = "com.hedera.hapi.node.base">>> This comment is special code for setting PBJ Compiler java package
option java_multiple_files = true;

/**
 * Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative
 * realm number (that number might be reused in other shards). And each account, file, and smart
 * contract instance within a given realm has a nonnegative number (which might be reused in other
 * realms).  Every account, file, and smart contract instance is within exactly one realm. So a
 * FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.
 * Each realm maintains a single counter for assigning numbers,  so if there is a file with ID
 * 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.
 *
 * Everything is partitioned into realms so that each Solidity smart contract can  access everything
 * in just a single realm, locking all those entities while it's  running, but other smart contracts
 * could potentially run in other realms in  parallel. So realms allow Solidity to be parallelized
 * somewhat, even though the  language itself assumes everything is serial.
 */
message ShardID {
    /**
     * the shard number (nonnegative)
     */
    int64 shardNum = 1;
}

/**
 * The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and
 * contract instance belongs to exactly one realm.
 */
message RealmID {
    /**
     * The shard number (nonnegative)
     */
    int64 shardNum = 1;

    /**
     * The realm number (nonnegative)
     */
    int64 realmNum = 2;
}

/**
 * A specific hash algorithm.
 *
 * We did not reuse Record Stream `HashAlgorithm` here because in all cases,
 * currently, this will be `SHA2_384` and if that is the default value then
 * we can save space by not serializing it, whereas `HASH_ALGORITHM_UNKNOWN`
 * is the default for Record Stream `HashAlgorithm`.
 *
 * Note that enum values here MUST NOT match the name of any other enum value
 * in the same `package`, as protobuf follows `C++` scope rules and all enum
 * _names_ are treated as global constants within the `package`.
 */
enum BlockHashAlgorithm {
    /**
     * A SHA2 algorithm SHA-384 hash.
     * <p>
     * This is the default value, if a field of this enumerated type is
     * not set, then this is the value that will be decoded when the
     * serialized message is read.
     */
    SHA2_384 = 0;
}

/**
 * The ID for an a cryptocurrency account
 */
message AccountID {
    /**
     * The shard number (nonnegative)
     */
    int64 shardNum = 1;

    /**
     * The realm number (nonnegative)
     */
    int64 realmNum = 2;

    /**
     * The account number unique within its realm which can be a non-negative integer, an alias public key or an EVM address.
     * For any AccountID fields in the query response, transaction record or transaction receipt only accountNum will
     * be populated.
     */
    oneof account {
        /**
         * A non-negative account number unique within its realm
         */
        int64 accountNum = 3;

        /**
         * The public key bytes to be used as the account's alias. The public key bytes are the result of serializing
         * a protobuf Key message for any primitive key type. Currently only primitive key bytes are supported as an alias
         * (ThresholdKey, KeyList, ContractID, and delegatable_contract_id are not supported)
         *
         * May also be the ethereum account 20-byte EVM address to be used initially in place of the public key bytes. This EVM
         * address may be either the encoded form of the shard.realm.num or the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
         *
         * At most one account can ever have a given alias and it is used for account creation if it
         * was automatically created using a crypto transfer. It will be null if an account is created normally.
         * It is immutable once it is set for an account.
         *
         * If a transaction auto-creates the account, any further transfers to that alias will simply be deposited
         * in that account, without creating anything, and with no creation fee being charged.
         *
         * If a transaction lazily-creates this account, a subsequent transaction will be required containing the public key bytes
         * that map to the EVM address bytes. The provided public key bytes will then serve as the final alias bytes.
         */
        bytes alias = 4;
    }
}

/**
 * Identifier for a unique token (or "NFT"), used by both contract and token services.
 */
message NftID {
    /**
     * The (non-fungible) token of which this NFT is an instance; uppercase for "ID"
     * for backward compatibility with original definition of this field.
     */
    TokenID token_ID = 1;

    /**
     * The serial number of this NFT within its token type
     */
    int64 serial_number = 2;
}

/**
 * The ID for a file
 */
message FileID {
    /**
     * The shard number (nonnegative)
     */
    int64 shardNum = 1;

    /**
     * The realm number (nonnegative)
     */
    int64 realmNum = 2;

    /**
     * A nonnegative File number unique within its realm
     */
    int64 fileNum = 3;
}

/**
 * The ID for a smart contract instance
 */
message ContractID {
    /**
     * The shard number (nonnegative)
     */
    int64 shardNum = 1;

    /**
     * The realm number (nonnegative)
     */
    int64 realmNum = 2;

    oneof contract {
        /**
        * A nonnegative number unique within a given shard and realm
        */
        int64 contractNum = 3;

        /**
        * The 20-byte EVM address of the contract to call.
        *
        * Every contract has an EVM address determined by its <tt>shard.realm.num</tt> id.
        * This address is as follows:
        *   <ol>
        *     <li>The first 4 bytes are the big-endian representation of the shard.</li>
        *     <li>The next 8 bytes are the big-endian representation of the realm.</li>
        *     <li>The final 8 bytes are the big-endian representation of the number.</li>
        *   </ol>
        *
        * Contracts created via CREATE2 have an <b>additional, primary address</b> that is
        * derived from the <a href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>
        * specification, and does not have a simple relation to a <tt>shard.realm.num</tt> id.
        *
        * (Please do note that CREATE2 contracts can also be referenced by the three-part
        * EVM address described above.)
        */
        bytes evm_address = 4;
    }
}

/**
 * The ID for a transaction. This is used for retrieving receipts and records for a transaction, for
 * appending to a file right after creating it, for instantiating a smart contract with bytecode in
 * a file just created, and internally by the network for detecting when duplicate transactions are
 * submitted. A user might get a transaction processed faster by submitting it to N nodes, each with
 * a different node account, but all with the same TransactionID. Then, the transaction will take
 * effect when the first of all those nodes submits the transaction and it reaches consensus. The
 * other transactions will not take effect. So this could make the transaction take effect faster,
 * if any given node might be slow. However, the full transaction fee is charged for each
 * transaction, so the total fee is N times as much if the transaction is sent to N nodes.
 *
 * Applicable to Scheduled Transactions:
 *  - The ID of a Scheduled Transaction has transactionValidStart and accountIDs inherited from the
 *    ScheduleCreate transaction that created it. That is to say that they are equal
 *  - The scheduled property is true for Scheduled Transactions
 *  - transactionValidStart, accountID and scheduled properties should be omitted
 */
message TransactionID {
    /**
     * The transaction is invalid if consensusTimestamp < transactionID.transactionStartValid
     */
    Timestamp transactionValidStart = 1;

    /**
     * The Account ID that paid for this transaction
     */
    AccountID accountID = 2;

    /**
     * Whether the Transaction is of type Scheduled or no
     */
    bool scheduled = 3;

    /**
     * The identifier for an internal transaction that was spawned as part
     * of handling a user transaction. (These internal transactions share the
     * transactionValidStart and accountID of the user transaction, so a
     * nonce is necessary to give them a unique TransactionID.)
     *
     * An example is when a "parent" ContractCreate or ContractCall transaction
     * calls one or more HTS precompiled contracts; each of the "child"
     * transactions spawned for a precompile has a id with a different nonce.
     */
    int32 nonce = 4;
}

/**
 * An account, and the amount that it sends or receives during a cryptocurrency or token transfer.
 */
message AccountAmount {
    /**
     * The Account ID that sends/receives cryptocurrency or tokens
     */
    AccountID accountID = 1;

    /**
     * The amount of tinybars (for Crypto transfers) or in the lowest
     * denomination (for Token transfers) that the account sends(negative) or
     * receives(positive)
     */
    sint64 amount = 2;

    /**
     * If true then the transfer is expected to be an approved allowance and the
     * accountID is expected to be the owner. The default is false (omitted).
     */
    bool is_approval = 3;
}

/**
 * A list of accounts and amounts to transfer out of each account (negative) or into it (positive).
 */
message TransferList {
    /**
     * Multiple list of AccountAmount pairs, each of which has an account and
     * an amount to transfer into it (positive) or out of it (negative)
     */
    repeated AccountAmount accountAmounts = 1;
}

/**
 * A sender account, a receiver account, and the serial number of an NFT of a Token with
 * NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be the default AccountID instance
 * (0.0.0) and when burning NFTs, the receiver will be the default AccountID instance.
 */
message NftTransfer {
    /**
     * The accountID of the sender
     */
    AccountID senderAccountID = 1;

    /**
     * The accountID of the receiver
     */
    AccountID receiverAccountID = 2;

    /**
     * The serial number of the NFT
     */
    int64 serialNumber = 3;

    /**
     * If true then the transfer is expected to be an approved allowance and the
     * senderAccountID is expected to be the owner. The default is false (omitted).
     */
    bool is_approval = 4;
}

/**
 * A list of token IDs and amounts representing the transferred out (negative) or into (positive)
 * amounts, represented in the lowest denomination of the token
 */
message TokenTransferList {
    /**
     * The ID of the token
     */
    TokenID token = 1;

    /**
     * Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which
     * has an account and amount
     */
    repeated AccountAmount transfers = 2;

    /**
     * Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of
     * which has a sender and receiver account, including the serial number of the NFT
     */
    repeated NftTransfer nftTransfers = 3;

    /**
     * If present, the number of decimals this fungible token type is expected to have. The transfer
     * will fail with UNEXPECTED_TOKEN_DECIMALS if the actual decimals differ.
     */
    google.protobuf.UInt32Value expected_decimals = 4;
}

/**
 * A rational number, used to set the amount of a value transfer to collect as a custom fee
 */
message Fraction {
    /**
     * The rational's numerator
     */
    int64 numerator = 1;

    /**
     * The rational's denominator; a zero value will result in FRACTION_DIVIDES_BY_ZERO
     */
    int64 denominator = 2;
}

/**
 * Unique identifier for a topic (used by the consensus service)
 */
message TopicID {
    /**
     * The shard number (nonnegative)
     */
    int64 shardNum = 1;

    /**
     * The realm number (nonnegative)
     */
    int64 realmNum = 2;

    /**
     * Unique topic identifier within a realm (nonnegative).
     */
    int64 topicNum = 3;
}

/**
 * Unique identifier for a token
 */
message TokenID {
    /**
     * A nonnegative shard number
     */
    int64 shardNum = 1;

    /**
     * A nonnegative realm number
     */
    int64 realmNum = 2;

    /**
     * A nonnegative token number
     */
    int64 tokenNum = 3;
}

/**
 * Unique identifier for a Schedule
 */
message ScheduleID {
    /**
     * A nonnegative shard number
     */
    int64 shardNum = 1;

    /**
     * A nonnegative realm number
     */
    int64 realmNum = 2;

    /**
     * A nonnegative schedule number
     */
    int64 scheduleNum = 3;
}

/**
 * Possible Token Types (IWA Compatibility).
 * Apart from fungible and non-fungible, Tokens can have either a common or unique representation.
 * This distinction might seem subtle, but it is important when considering how tokens can be traced
 * and if they can have isolated and unique properties.
 */
enum TokenType {
    /**
     * Interchangeable value with one another, where any quantity of them has the same value as
     * another equal quantity if they are in the same class.  Share a single set of properties, not
     * distinct from one another. Simply represented as a balance or quantity to a given Hedera
     * account.
     */
    FUNGIBLE_COMMON = 0;

    /**
     * Unique, not interchangeable with other tokens of the same type as they typically have
     * different values.  Individually traced and can carry unique properties (e.g. serial number).
     */
    NON_FUNGIBLE_UNIQUE = 1;
}

/**
 * Allows a set of resource prices to be scoped to a certain type of a HAPI operation.
 *
 * For example, the resource prices for a TokenMint operation are different between minting fungible
 * and non-fungible tokens. This enum allows us to "mark" a set of prices as applying to one or the
 * other.
 *
 * Similarly, the resource prices for a basic TokenCreate without a custom fee schedule yield a
 * total price of $1. The resource prices for a TokenCreate with a custom fee schedule are different
 * and yield a total base price of $2.
 */
enum SubType {
    /**
     * The resource prices have no special scope
     */
    DEFAULT = 0;

    /**
     * The resource prices are scoped to an operation on a fungible common token
     */
    TOKEN_FUNGIBLE_COMMON = 1;

    /**
     * The resource prices are scoped to an operation on a non-fungible unique token
     */
    TOKEN_NON_FUNGIBLE_UNIQUE = 2;

    /**
     * The resource prices are scoped to an operation on a fungible common
     * token with a custom fee schedule
     */
    TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES = 3;

    /**
     * The resource prices are scoped to an operation on a non-fungible unique
     * token with a custom fee schedule
     */
    TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES = 4;

    /**
     * The resource prices are scoped to a ScheduleCreate containing a ContractCall.
     */
    SCHEDULE_CREATE_CONTRACT_CALL = 5;
}

/**
 * Possible Token Supply Types (IWA Compatibility).
 * Indicates how many tokens can have during its lifetime.
 */
enum TokenSupplyType {
    /**
     * Indicates that tokens of that type have an upper bound of Long.MAX_VALUE.
     */
    INFINITE = 0;

    /**
     * Indicates that tokens of that type have an upper bound of maxSupply,
     * provided on token creation.
     */
    FINITE = 1;
}

/**
 * Types of validation strategies for token keys.
 */
enum TokenKeyValidation {
    /**
     * Currently the default behaviour. It will perform all token key validations.
     */
    FULL_VALIDATION = 0;

    /**
     * Perform no validations at all for all passed token keys.
     */
    NO_VALIDATION = 1;
}

/**
 * Possible Freeze statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in
 * TokenRelationship
 */
enum TokenFreezeStatus {
    /**
     * UNDOCUMENTED
     */
    FreezeNotApplicable = 0;

    /**
     * UNDOCUMENTED
     */
    Frozen = 1;

    /**
     * UNDOCUMENTED
     */
    Unfrozen = 2;
}

/**
 * Possible KYC statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in TokenRelationship
 */
enum TokenKycStatus {
    /**
     * UNDOCUMENTED
     */
    KycNotApplicable = 0;

    /**
     * UNDOCUMENTED
     */
    Granted = 1;

    /**
     * UNDOCUMENTED
     */
    Revoked = 2;
}

/**
 * Possible Pause statuses returned on TokenGetInfoQuery
 */
enum TokenPauseStatus {
    /**
     * Indicates that a Token has no pauseKey
     */
    PauseNotApplicable = 0;

    /**
     * Indicates that a Token is Paused
     */
    Paused = 1;

    /**
     * Indicates that a Token is Unpaused.
     */
    Unpaused = 2;
}

/**
 * A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where
 * in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call
 * these public keys <b>primitive keys</b>.
 *
 * If an account has primitive key associated to it, then the corresponding private key must sign
 * any transaction to transfer cryptocurrency out of it.
 *
 * A Key can also be the ID of a smart contract instance, which is then authorized to perform any
 * precompiled contract action that requires this key to sign.
 *
 * Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID
 * will actually create a cryptographic signature. It only means that when the contract calls a
 * precompiled contract, the resulting "child transaction" will be authorized to perform any action
 * controlled by the Key.
 *
 * A Key can be a "threshold key", which means a list of M keys, any N of which must sign in order
 * for the threshold signature to be considered valid. The keys within a threshold signature may
 * themselves be threshold signatures, to allow complex signature requirements.
 *
 * A Key can be a "key list" where all keys in the list must sign unless specified otherwise in the
 * documentation for a specific transaction type (e.g.  FileDeleteTransactionBody).  Their use is
 * dependent on context. For example, a Hedera file is created with a list of keys, where all of
 * them must sign a transaction to create or modify the file, but only one of them is needed to sign
 * a transaction to delete the file. So it's a single list that sometimes acts as a 1-of-M threshold
 * key, and sometimes acts as an M-of-M threshold key.  A key list is always an M-of-M, unless
 * specified otherwise in documentation. A key list can have nested key lists or threshold keys.
 * Nested key lists are always M-of-M. A key list can have repeated primitive public keys, but all
 * repeated keys are only required to sign once.
 *
 * A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so this mutual
 * recursion would allow nesting arbitrarily deep. A ThresholdKey which contains a list of primitive
 * keys has 3 levels: ThresholdKey -> KeyList -> Key. A KeyList which contains several primitive
 * keys has 2 levels: KeyList -> Key. A Key with 2 levels of nested ThresholdKeys has 7 levels:
 * Key -> ThresholdKey -> KeyList -> Key -> ThresholdKey -> KeyList -> Key.
 *
 * Each Key should not have more than 46 levels, which implies 15 levels of nested ThresholdKeys.
 */
message Key {
    oneof key {
        /**
         * smart contract instance that is authorized as if it had signed with a key
         */
        ContractID contractID = 1;

        /**
         * Ed25519 public key bytes
         */
        bytes ed25519 = 2;

        /**
         * (NOT SUPPORTED) RSA-3072 public key bytes
         */
        bytes RSA_3072 = 3;

        /**
         * (NOT SUPPORTED) ECDSA with the p-384 curve public key bytes
         */
        bytes ECDSA_384 = 4;

        /**
         * a threshold N followed by a list of M keys, any N of which are required to form a valid
         * signature
         */
        ThresholdKey thresholdKey = 5;

        /**
         * A list of Keys of the Key type.
         */
        KeyList keyList = 6;

        /**
         * Compressed ECDSA(secp256k1) public key bytes
         */
        bytes ECDSA_secp256k1 = 7;

        /**
         * A smart contract that, if the recipient of the active message frame, should be treated
         * as having signed. (Note this does not mean the <i>code being executed in the frame</i>
         * will belong to the given contract, since it could be running another contract's code via
         * <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the
         * contractID key, which also requires the code in the active message frame belong to the
         * the contract with the given id.)
         */
        ContractID delegatable_contract_id = 8;
    }
}

/**
 * A set of public keys that are used together to form a threshold signature.  If the threshold is N
 * and there are M keys, then this is an N of M threshold signature. If an account is associated
 * with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list
 * of M signatures, where at most M-N of them are blank, and the other at least N of them are valid
 * signatures corresponding to at least N of the public keys listed here.
 */
message ThresholdKey {
    /**
     * A valid signature set must have at least this many signatures
     */
    uint32 threshold = 1;

    /**
     * List of all the keys that can sign
     */
    KeyList keys = 2;
}

/**
 * A list of keys that requires all keys (M-of-M) to sign unless otherwise specified in
 * documentation. A KeyList may contain repeated keys, but all repeated keys are only required to
 * sign once.
 */
message KeyList {
    /**
     * list of keys
     */
    repeated Key keys = 1;
}

/**
 * This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
 * here only for historical reasons.
 *
 * Please use the SignaturePair and SignatureMap messages.
 */
message Signature {
    option deprecated = true;

    oneof signature {
        /**
         * smart contract virtual signature (always length zero)
         */
        bytes contract = 1;

        /**
         * ed25519 signature bytes
         */
        bytes ed25519 = 2;

        /**
         * RSA-3072 signature bytes
         */
        bytes RSA_3072 = 3;

        /**
         * ECDSA p-384 signature bytes
         */
        bytes ECDSA_384 = 4;

        /**
         * A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M
         * signatures, at least N of which are non-null.
         */
        ThresholdSignature thresholdSignature = 5;

        /**
         * A list of M signatures, each corresponding to a Key in a KeyList of the same length.
         */
        SignatureList signatureList = 6;
    }
}

/**
 * This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
 * here only for historical reasons.
 *
 * Please use the SignaturePair and SignatureMap messages.
 */
message ThresholdSignature {
    option deprecated = true;

    /**
     * for an N-of-M threshold key, this is a list of M signatures, at least N of which must be
     * non-null
     */
    SignatureList sigs = 2;
}

/**
 * This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
 * here only for historical reasons.
 *
 * Please use the SignaturePair and SignatureMap messages.
 */
message SignatureList {
    option deprecated = true;

    /**
     * each signature corresponds to a Key in the KeyList
     */
    repeated Signature sigs = 2;
}

/**
 * The client may use any number of bytes from zero to the whole length of the public key for
 * pubKeyPrefix. If zero bytes are used, then it must be that only one primitive key is required
 * to sign the linked transaction; it will surely resolve to <tt>INVALID_SIGNATURE</tt> otherwise.
 *
 * <b>IMPORTANT:</b> In the special case that a signature is being provided for a key used to
 * authorize a precompiled contract, the <tt>pubKeyPrefix</tt> must contain the <b>entire public
 * key</b>! That is, if the key is a Ed25519 key, the <tt>pubKeyPrefix</tt> should be 32 bytes
 * long. If the key is a ECDSA(secp256k1) key, the <tt>pubKeyPrefix</tt> should be 33 bytes long,
 * since we require the compressed form of the public key.
 *
 * Only Ed25519 and ECDSA(secp256k1) keys and hence signatures are currently supported.
 */
message SignaturePair {
    /**
     * First few bytes of the public key
     */
    bytes pubKeyPrefix = 1;

    oneof signature {
        /**
         * smart contract virtual signature (always length zero)
         */
        bytes contract = 2;

        /**
         * ed25519 signature
         */
        bytes ed25519 = 3;

        /**
         * RSA-3072 signature
         */
        bytes RSA_3072 = 4;

        /**
         * ECDSA p-384 signature
         */
        bytes ECDSA_384 = 5;

        /**
         * ECDSA(secp256k1) signature
         */
        bytes ECDSA_secp256k1 = 6;
    }
}

/**
 * A set of signatures corresponding to every unique public key used to sign a given transaction. If
 * one public key matches more than one prefixes on the signature map, the transaction containing
 * the map will fail immediately with the response code KEY_PREFIX_MISMATCH.
 */
message SignatureMap {
    /**
     * Each signature pair corresponds to a unique Key required to sign the transaction.
     */
    repeated SignaturePair sigPair = 1;
}

/**
 * The transactions and queries supported by Hedera Hashgraph.
 */
enum HederaFunctionality {
    /**
     * UNSPECIFIED - Need to keep first value as unspecified because first element is ignored and
     * not parsed (0 is ignored by parser)
     */
    NONE = 0;

    /**
     * crypto transfer
     */
    CryptoTransfer = 1;

    /**
     * crypto update account
     */
    CryptoUpdate = 2;

    /**
     * crypto delete account
     */
    CryptoDelete = 3;

    /**
     * Add a livehash to a crypto account
     */
    CryptoAddLiveHash = 4;

    /**
     * Delete a livehash from a crypto account
     */
    CryptoDeleteLiveHash = 5;

    /**
     * Smart Contract Call
     */
    ContractCall = 6;

    /**
     * Smart Contract Create Contract
     */
    ContractCreate = 7;

    /**
     * Smart Contract update contract
     */
    ContractUpdate = 8;

    /**
     * File Operation create file
     */
    FileCreate = 9;

    /**
     * File Operation append file
     */
    FileAppend = 10;

    /**
     * File Operation update file
     */
    FileUpdate = 11;

    /**
     * File Operation delete file
     */
    FileDelete = 12;

    /**
     * crypto get account balance
     */
    CryptoGetAccountBalance = 13;

    /**
     * crypto get account record
     */
    CryptoGetAccountRecords = 14;

    /**
     * Crypto get info
     */
    CryptoGetInfo = 15;

    /**
     * Smart Contract Call
     */
    ContractCallLocal = 16;

    /**
     * Smart Contract get info
     */
    ContractGetInfo = 17;

    /**
     * Smart Contract, get the runtime code
     */
    ContractGetBytecode = 18;

    /**
     * Smart Contract, get by solidity ID
     */
    GetBySolidityID = 19;

    /**
     * Smart Contract, get by key
     */
    GetByKey = 20;

    /**
     * Get a live hash from a crypto account
     */
    CryptoGetLiveHash = 21;

    /**
     * Crypto, get the stakers for the node
     */
    CryptoGetStakers = 22;

    /**
     * File Operations get file contents
     */
    FileGetContents = 23;

    /**
     * File Operations get the info of the file
     */
    FileGetInfo = 24;

    /**
     * Crypto get the transaction records
     */
    TransactionGetRecord = 25;

    /**
     * Contract get the transaction records
     */
    ContractGetRecords = 26;

    /**
     * crypto create account
     */
    CryptoCreate = 27;

    /**
     * system delete file
     */
    SystemDelete = 28;

    /**
     * system undelete file
     */
    SystemUndelete = 29;

    /**
     * delete contract
     */
    ContractDelete = 30;

    /**
     * freeze
     */
    Freeze = 31;

    /**
     * Create Tx Record
     */
    CreateTransactionRecord = 32;

    /**
     * Crypto Auto Renew
     */
    CryptoAccountAutoRenew = 33;

    /**
     * Contract Auto Renew
     */
    ContractAutoRenew = 34;

    /**
     * Get Version
     */
    GetVersionInfo = 35;

    /**
     * Transaction Get Receipt
     */
    TransactionGetReceipt = 36;

    /**
     * Create Topic
     */
    ConsensusCreateTopic = 50;

    /**
     * Update Topic
     */
    ConsensusUpdateTopic = 51;

    /**
     * Delete Topic
     */
    ConsensusDeleteTopic = 52;

    /**
     * Get Topic information
     */
    ConsensusGetTopicInfo = 53;

    /**
     * Submit message to topic
     */
    ConsensusSubmitMessage = 54;

    UncheckedSubmit = 55;
    /**
     * Create Token
     */
    TokenCreate = 56;

    /**
     * Get Token information
     */
    TokenGetInfo = 58;

    /**
     * Freeze Account
     */
    TokenFreezeAccount = 59;

    /**
     * Unfreeze Account
     */
    TokenUnfreezeAccount = 60;

    /**
     * Grant KYC to Account
     */
    TokenGrantKycToAccount = 61;

    /**
     * Revoke KYC from Account
     */
    TokenRevokeKycFromAccount = 62;

    /**
     * Delete Token
     */
    TokenDelete = 63;

    /**
     * Update Token
     */
    TokenUpdate = 64;

    /**
     * Mint tokens to treasury
     */
    TokenMint = 65;

    /**
     * Burn tokens from treasury
     */
    TokenBurn = 66;

    /**
     * Wipe token amount from Account holder
     */
    TokenAccountWipe = 67;

    /**
     * Associate tokens to an account
     */
    TokenAssociateToAccount = 68;

    /**
     * Dissociate tokens from an account
     */
    TokenDissociateFromAccount = 69;

    /**
     * Create Scheduled Transaction
     */
    ScheduleCreate = 70;

    /**
     * Delete Scheduled Transaction
     */
    ScheduleDelete = 71;

    /**
     * Sign Scheduled Transaction
     */
    ScheduleSign = 72;

    /**
     * Get Scheduled Transaction Information
     */
    ScheduleGetInfo = 73;

    /**
     * Get Token Account Nft Information
     */
    TokenGetAccountNftInfos = 74;

    /**
     * Get Token Nft Information
     */
    TokenGetNftInfo = 75;

    /**
     * Get Token Nft List Information
     */
    TokenGetNftInfos = 76;

    /**
     * Update a token's custom fee schedule, if permissible
     */
    TokenFeeScheduleUpdate = 77;

    /**
     * Get execution time(s) by TransactionID, if available
     */
    NetworkGetExecutionTime = 78;

    /**
     * Pause the Token
     */
    TokenPause = 79;

    /**
     * Unpause the Token
     */
    TokenUnpause = 80;

    /**
     * Approve allowance for a spender relative to the owner account
     */
    CryptoApproveAllowance = 81;

    /**
     * Deletes granted allowances on owner account
     */
    CryptoDeleteAllowance = 82;

    /**
     * Gets all the information about an account, including balance and allowances. This does not get the list of
     * account records.
     */
    GetAccountDetails = 83;

    /**
     * Ethereum Transaction
     */
    EthereumTransaction = 84;

    /**
     * Updates the staking info at the end of staking period to indicate new staking period has started.
     */
    NodeStakeUpdate = 85;

    /**
     * Generates a pseudorandom number.
     */
    UtilPrng = 86;

    /**
     * Get a record for a transaction.
     */
    TransactionGetFastRecord = 87;

    /**
     * Update the metadata of one or more NFT's of a specific token type.
     */
    TokenUpdateNfts = 88;

    /**
     * Create a node
     */
    NodeCreate = 89;

    /**
     * Update a node
     */
    NodeUpdate = 90;

    /**
     * Delete a node
     */
    NodeDelete = 91;

    /**
     * Transfer one or more token balances held by the requesting account to the treasury for each token type.
     */
    TokenReject = 92;

    /**
     * Airdrop one or more tokens to one or more accounts.
     */
    TokenAirdrop = 93;

    /**
    * Remove one or more pending airdrops from state on behalf of the sender(s) for each airdrop.
    */
    TokenCancelAirdrop = 94;

    /**
     * Claim one or more pending airdrops
     */
    TokenClaimAirdrop = 95;

    /**
     * A message produced as part of Threshold Signature Scheme (TSS) processing.
     */
    TssMessage = 96;

    /**
     * Submit a vote as part of the Threshold Signature Scheme (TSS) processing.
     */
    TssVote = 97;

    /**
     * Submit a node signature as part of the Threshold Signature Scheme (TSS) processing.
     */
    TssShareSignature = 98;

    /**
     * Submit a node public tss encryption key as part of the Threshold Signature Scheme (TSS).
     */
    TssEncryptionKey = 99;

    /**
     * Submit a signature of a state root hash gossiped to other nodes
     */
    StateSignatureTransaction = 100;
}

/**
 * A set of prices the nodes use in determining transaction and query fees, and constants involved
 * in fee calculations.  Nodes multiply the amount of resources consumed by a transaction or query
 * by the corresponding price to calculate the appropriate fee. Units are one-thousandth of a
 * tinyCent.
 */
message FeeComponents {
    /**
     * A minimum, the calculated fee must be greater than this value
     */
    int64 min = 1;

    /**
     * A maximum, the calculated fee must be less than this value
     */
    int64 max = 2;

    /**
     * A constant contribution to the fee
     */
    int64 constant = 3;

    /**
     * The price of bandwidth consumed by a transaction, measured in bytes
     */
    int64 bpt = 4;

    /**
     * The price per signature verification for a transaction
     */
    int64 vpt = 5;

    /**
     * The price of RAM consumed by a transaction, measured in byte-hours
     */
    int64 rbh = 6;

    /**
     * The price of storage consumed by a transaction, measured in byte-hours
     */
    int64 sbh = 7;

    /**
     * The price of computation for a smart contract transaction, measured in gas
     */
    int64 gas = 8;

    /**
     * The price per hbar transferred for a transfer
     */
    int64 tv = 9;

    /**
     * The price of bandwidth for data retrieved from memory for a response, measured in bytes
     */
    int64 bpr = 10;

    /**
     * The price of bandwidth for data retrieved from disk for a response, measured in bytes
     */
    int64 sbpr = 11;
}

/**
 * The fees for a specific transaction or query based on the fee data.
 */
message TransactionFeeSchedule {
    /**
     * A particular transaction or query
     */
    HederaFunctionality hederaFunctionality = 1;

    /**
     * Resource price coefficients
     */
    FeeData feeData = 2 [deprecated = true];

    /**
     * Resource price coefficients. Supports subtype price definition.
     */
    repeated FeeData fees = 3;
}

/**
 * The total fee charged for a transaction. It is composed of three components - a node fee that
 * compensates the specific node that submitted the transaction, a network fee that compensates the
 * network for assigning the transaction a consensus timestamp, and a service fee that compensates
 * the network for the ongoing maintenance of the consequences of the transaction.
 */
message FeeData {
    /**
     * Fee paid to the submitting node
     */
    FeeComponents nodedata = 1;

    /**
     * Fee paid to the network for processing a transaction into consensus
     */
    FeeComponents networkdata = 2;

    /**
     * Fee paid to the network for providing the service associated with the
     * transaction; for instance, storing a file
     */
    FeeComponents servicedata = 3;

    /**
     * SubType distinguishing between different types of FeeData, correlating
     * to the same HederaFunctionality
     */
    SubType subType = 4;
}

/**
 * A list of resource prices fee for different transactions and queries and the time period at which
 * this fee schedule will expire. Nodes use the prices to determine the fees for all transactions
 * based on how much of those resources each transaction uses.
 */
message FeeSchedule {
    /**
     * List of price coefficients for network resources
     */
    repeated TransactionFeeSchedule transactionFeeSchedule = 1;

    /**
     * FeeSchedule expiry time
     */
    TimestampSeconds expiryTime = 2;
}

/**
 * This contains two Fee Schedules with expiry timestamp.
 */
message CurrentAndNextFeeSchedule {
    /**
     * Contains current Fee Schedule
     */
    FeeSchedule currentFeeSchedule = 1;

    /**
     * Contains next Fee Schedule
     */
    FeeSchedule nextFeeSchedule = 2;
}

/**
 * Contains the IP address and the port representing a service endpoint of
 * a Node in a network. Used to reach the Hedera API and submit transactions
 * to the network.
 *
 * When the `domain_name` field is set, the `ipAddressV4` field
 * MUST NOT be set.<br/>
 * When the `ipAddressV4` field is set, the `domain_name` field
 * MUST NOT be set.
 */
message ServiceEndpoint {
    /**
     * The 4-byte IPv4 address of the endpoint encoded in left to right order
     * (e.g. 127.0.0.1 has bytes [127, 0, 0, 1])
     */
    bytes ipAddressV4 = 1;

    /**
     * The port of the service endpoint
     */
    int32 port = 2;

    /**
     * A node domain name.<br/>
     * This MUST be the fully qualified domain(DNS) name of the node.<br/>
     * This value MUST NOT be more than 253 characters.
     * domain_name and ipAddressV4 are mutually exclusive.
     * When the `domain_name` field is set, the `ipAddressV4` field MUST NOT be set.<br/>
     * When the `ipAddressV4` field is set, the `domain_name` field MUST NOT be set.
     */
    string domain_name = 3;
}

/**
 * The data about a node, including its service endpoints and the Hedera account to be paid for
 * services provided by the node (that is, queries answered and transactions submitted.)
 *
 * If the `serviceEndpoint` list is not set, or empty, then the endpoint given by the
 * (deprecated) `ipAddress` and `portno` fields should be used.
 *
 * All fields are populated in the 0.0.102 address book file while only fields that start with # are
 * populated in the 0.0.101 address book file.
 */
message NodeAddress {
    /**
     * The IP address of the Node with separator & octets encoded in UTF-8.  Usage is deprecated,
     * ServiceEndpoint is preferred to retrieve a node's list of IP addresses and ports
     */
    bytes ipAddress = 1 [deprecated = true];

    /**
     * The port number of the grpc server for the node.  Usage is deprecated, ServiceEndpoint is
     * preferred to retrieve a node's list of IP addresses and ports
     */
    int32 portno = 2 [deprecated = true];

    /**
     * Usage is deprecated, nodeAccountId is preferred to retrieve a node's account ID
     */
    bytes memo = 3 [deprecated = true];

    /**
     * The node's X509 RSA public key used to sign stream files (e.g., record stream
     * files). Precisely, this field is a string of hexadecimal characters which,
     * translated to binary, are the public key's DER encoding.
     */
    string RSA_PubKey = 4;

    /**
     * # A non-sequential identifier for the node
     */
    int64 nodeId = 5;

    /**
     * # The account to be paid for queries and transactions sent to this node
     */
    AccountID nodeAccountId = 6;

    /**
     * # Hash of the node's TLS certificate. Precisely, this field is a string of
     * hexadecimal characters which, translated to binary, are the SHA-384 hash of
     * the UTF-8 NFKD encoding of the node's TLS cert in PEM format. Its value can be
     * used to verify the node's certificate it presents during TLS negotiations.
     */
    bytes nodeCertHash = 7;

    /**
     * # A node's service IP addresses and ports
     */
    repeated ServiceEndpoint serviceEndpoint = 8;

    /**
     * A description of the node, with UTF-8 encoding up to 100 bytes
     */
    string description = 9;

    /**
     * [Deprecated] The amount of tinybars staked to the node
     */
    int64 stake = 10 [deprecated = true];
}

/**
 * A list of nodes and their metadata that contains all details of the nodes for the network.  Used
 * to parse the contents of system files <tt>0.0.101</tt> and <tt>0.0.102</tt>.
 */
message NodeAddressBook {
    /**
     * Metadata of all nodes in the network
     */
    repeated NodeAddress nodeAddress = 1;
}

/**
 * Hedera follows semantic versioning (https://semver.org/) for both the HAPI protobufs and the
 * Services software.  This type allows the <tt>getVersionInfo</tt> query in the
 * <tt>NetworkService</tt> to return the deployed versions of both protobufs and software on the
 * node answering the query.
 */
message SemanticVersion {
    /**
     * Increases with incompatible API changes
     */
    int32 major = 1;

    /**
     * Increases with backwards-compatible new functionality
     */
    int32 minor = 2;

    /**
     * Increases with backwards-compatible bug fixes
     */
    int32 patch = 3;

    /**
     * A pre-release version MAY be denoted by appending a hyphen and a series of dot separated
     * identifiers (https://semver.org/#spec-item-9); so given a semver 0.14.0-alpha.1+21AF26D3,
     * this field would contain 'alpha.1'
     */
    string pre = 4;

    /**
     * Build metadata MAY be denoted by appending a plus sign and a series of dot separated
     * identifiers immediately following the patch or pre-release version
     * (https://semver.org/#spec-item-10); so given a semver 0.14.0-alpha.1+21AF26D3, this field
     * would contain '21AF26D3'
     */
    string build = 5;
}

/**
 * UNDOCUMENTED
 */
message Setting {
    /**
     * name of the property
     */
    string name = 1;

    /**
     * value of the property
     */
    string value = 2;

    /**
     * any data associated with property
     */
    bytes data = 3;
}

/**
 * UNDOCUMENTED
 */
message ServicesConfigurationList {
    /**
     * list of name value pairs of the application properties
     */
    repeated Setting nameValue = 1;
}

/**
 * Token's information related to the given Account
 */
message TokenRelationship {
    /**
     * The ID of the token
     */
    TokenID tokenId = 1;

    /**
     * The Symbol of the token
     */
    string symbol = 2;

    /**
     * For token of type FUNGIBLE_COMMON - the balance that the Account holds in the smallest
     * denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of NFTs held by the account
     */
    uint64 balance = 3;

    /**
     * The KYC status of the account (KycNotApplicable, Granted or Revoked). If the token does not
     * have KYC key, KycNotApplicable is returned
     */
    TokenKycStatus kycStatus = 4;

    /**
     * The Freeze status of the account (FreezeNotApplicable, Frozen or Unfrozen). If the token does
     * not have Freeze key, FreezeNotApplicable is returned
     */
    TokenFreezeStatus freezeStatus = 5;

    /**
     * Tokens divide into <tt>10<sup>decimals</sup></tt> pieces
     */
    uint32 decimals = 6;

    /**
     * Specifies if the relationship is created implicitly. False : explicitly associated, True :
     * implicitly associated.
     */
    bool automatic_association = 7;
}

/**
 * A number of <i>transferable units</i> of a certain token.
 *
 * The transferable unit of a token is its smallest denomination, as given by the token's
 * <tt>decimals</tt> property---each minted token contains <tt>10<sup>decimals</sup></tt>
 * transferable units. For example, we could think of the cent as the transferable unit of the US
 * dollar (<tt>decimals=2</tt>); and the tinybar as the transferable unit of hbar
 * (<tt>decimals=8</tt>).
 *
 * Transferable units are not directly comparable across different tokens.
 */
message TokenBalance {
    /**
     * A unique token id
     */
    TokenID tokenId = 1;

    /**
     * Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
     * balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
     * NFTs held by the account
     */
    uint64 balance = 2;

    /**
     * Tokens divide into <tt>10<sup>decimals</sup></tt> pieces
     */
    uint32 decimals = 3;
}

/**
 * A sequence of token balances
 */
message TokenBalances {
    repeated TokenBalance tokenBalances = 1;
}

/* A token - account association */
message TokenAssociation {
    TokenID token_id = 1;  // The token involved in the association
    AccountID account_id = 2; // The account involved in the association
}

/**
 * Staking metadata for an account or a contract returned in CryptoGetInfo or ContractGetInfo queries
 */
message StakingInfo {

    /**
     * If true, this account or contract declined to receive a staking reward.
     */
    bool decline_reward = 1;

    /**
     * The staking period during which either the staking settings for this account or contract changed (such as starting
     * staking or changing staked_node_id) or the most recent reward was earned, whichever is later. If this account or contract
     * is not currently staked to a node, then this field is not set.
     */
    Timestamp stake_period_start = 2;

    /**
     * The amount in tinybars that will be received in the next reward situation.
     */
    int64 pending_reward = 3;

    /**
     * The total of balance of all accounts staked to this account or contract.
     */
    int64 staked_to_me = 4;

    /**
     * ID of the account or node to which this account or contract is staking.
     */
    oneof staked_id {

        /**
         * The account to which this account or contract is staking.
         */
        AccountID staked_account_id = 5;

        /**
         * The ID of the node this account or contract is staked to.
         */
        int64 staked_node_id = 6;
    }
}

/**
 * A unique, composite, identifier for a pending airdrop.
 *
 * Each pending airdrop SHALL be uniquely identified by a PendingAirdropId.
 * A PendingAirdropId SHALL be recorded when created and MUST be provided in any transaction
 * that would modify that pending airdrop (such as a `claimAirdrop` or `cancelAirdrop`).
 */
message PendingAirdropId {
    /**
     * A sending account.<br/>
     * This is the account that initiated, and SHALL fund, this pending airdrop.<br/>
     * This field is REQUIRED.
     */
    AccountID sender_id = 1;

    /**
     * A receiving account.<br/>
     * This is the ID of the account that SHALL receive the airdrop.<br/>
     * This field is REQUIRED.
     */
    AccountID receiver_id = 2;

    oneof token_reference {
        /**
         * A token ID.<br/>
         * This is the type of token for a fungible/common token airdrop.<br/>
         * This field is REQUIRED for a fungible/common token and MUST NOT be used for a
         * non-fungible/unique token.
         */
        TokenID fungible_token_type = 3;

        /**
         * The id of a single NFT, consisting of a Token ID and serial number.<br/>
         * This is the type of token for a non-fungible/unique token airdrop.<br/>
         * This field is REQUIRED for a non-fungible/unique token and MUST NOT be used for a
         * fungible/common token.
         */
        NftID non_fungible_token = 4;
    }
}

/**
 * A single pending airdrop value.
 *
 * This message SHALL record the airdrop amount for a fungible/common token.<br/>
 * This message SHOULD be null for a non-fungible/unique token.<br/>
 * If a non-null `PendingAirdropValue` is set for a non-fungible/unique token, the amount
 * field MUST be `0`.
 *
 * It is RECOMMENDED that implementations store pending airdrop information as a key-value map
 * from `PendingAirdropId` to `PendingAirdropValue`, with a `null` value used for non-fungible
 * pending airdrops.
 */
message PendingAirdropValue {
    /**
     * An amount to transfer for fungible/common tokens.<br/>
     * This is expressed in the smallest available units for that token
     * (i.e. 10<sup>-`decimals`</sup> whole tokens).<br/>
     * This amount SHALL be transferred from the sender to the receiver, if claimed.<br/>
     * If the token is a fungible/common token, this value MUST be strictly greater than `0`.
     * If the token is a non-fungible/unique token, this message SHOULD NOT be set, and if
     * set, this field MUST be `0`.
     */
    uint64 amount = 1;
}
