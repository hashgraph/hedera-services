syntax = "proto3";

package com.hedera.hapi.node.state.history;

/*
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import "timestamp.proto";

option java_package = "com.hederahashgraph.api.proto.java";
// <<<pbj.java_package = "com.hedera.hapi.node.state.history">>> This comment is special code for setting PBJ Compiler java package
option java_multiple_files = true;

/**
 * A view of the network roster suitable for recursive proofs that
 * certain metadata was derived from the ledger id in a manner that
 * can trusted throughout any period the network's aBFT security
 * was not compromised; no matter how nodes were added, removed, or
 * updated during that period.
 */
message HistoryAddressBook {
  repeated HistoryAddressBookEntry address_book_entries = 1;
}

/**
 * An entry in the view of the network roster suitable for recursive
 * proofs that certain metadata was derived from the ledger id in a
 * manner that can trusted throughout any period the network's aBFT
 * security was not compromised; no matter how nodes were added,
 * removed, or updated during that period.
 */
message HistoryAddressBookEntry {
  /**
   * The node id.
   */
  uint64 node_id = 1;
  /**
   * The weight of the node.
   */
  uint64 weight = 2;
  /**
   * A public key used to contribute to a recursive SNARK that proves
   * certain metadata was derived from the ledger id in a manner that
   * can trusted throughout any period the network's aBFT security
   * was not compromised; no matter how nodes were added, removed, or
   * updated during that period.
   */
  bytes proof_public_key = 3;
}

/**
 * A set of Schnorr keys for a node; that is, the key the node is
 * currently using and the key it party wishes to use for the next
 * proof roster assembly.
 */
message ProofKeySet {
  /**
   * The consensus time at which the network adopted the current
   * Schnorr key in this set. An adoption time that is sufficiently
   * tardy relative to the latest assembly start time may result
   * in the node's key being omitted from the proof roster.
   */
  proto.Timestamp adoption_time = 2;
  /**
   * The proof key the node is using.
   */
  bytes key = 3;
  /**
   * If not null, the proof key the node wishes to use in all future
   * proof roster. Will be adopted at the beginning of the next
   * roster transition phase; so the node should begin using it
   * then.
   */
  bytes next_key = 4;
}

/**
 * A key a node will use to contribute its signature to proofs
 * that certain history (that is, address book with associated
 * metadata) belongs to the chain of trust for a ledger id.
 */
message ProofKey {
  /**
   * The node id.
   */
  uint64 node_id = 1;
  /**
   * The key.
   */
  bytes key = 2;
}

/**
 * A proof that some address book history belongs to a ledger id's
 * chain of trust.
 */
message HistoryProof {
  /**
   * The hash of the source address book.
   */
  bytes source_address_book_hash = 1;
  /**
   * The hash of the target address book.
   */
  bytes target_address_book_hash = 2;
  /**
   * The metadata tagged to the target address book.
   */
  bytes metadata = 3;
  /**
   * The proof keys for the source address book.
   */
  repeated ProofKey proof_keys = 4;
  /**
   * The recursive SNARK that proves the chain of trust.
   */
  bytes proof = 5;
}

/**
 * Summary of the status of constructing a metadata proof, necessary to
 * ensure deterministic construction ending in a roster with sufficient
 * weight to enact its own constructions.
 */
message HistoryProofConstruction {
  /**
   * The construction id.
   */
  uint64 construction_id = 1;
  /**
   * The hash of the roster whose weights are used to determine when
   * certain thresholds are during construction.
   */
  bytes source_roster_hash = 2;
  /**
   * If set, the proof that the address book of the source roster belongs
   * to the the ledger id's chain of trust; if not set, the source roster's
   * address book must *be* the ledger id.
   */
  HistoryProof source_proof = 3;
  /**
   * The hash of the roster whose weights are used to assess progress
   * toward obtaining proof keys for parties that hold at least a
   * strong minority of the stake in that roster.
   */
  bytes target_roster_hash = 4;

  oneof assembly_time {
    /**
     * If the network is still gathering proof keys for this
     * construction, the next time at which nodes should stop waiting
     * for tardy proof keys and assembly the history to be proven as
     * soon as it has the associated metadata and proof keys for nodes
     * with >2/3 weight in the target roster.
     */
    proto.Timestamp grace_period_end_time = 5;
    /**
     * If the network has gathered enough proof keys to assemble the
     * history for this construction, the cutoff time at which those
     * keys must have been adopted to be included in the final history.
     */
    proto.Timestamp assembly_start_time = 6;
  }
  /**
   * When this construction is complete, the recursive proof that
   * the target roster's address book and associated metadata belong
   * to the ledger id's chain of trust.
   */
  HistoryProof target_proof = 7;
}

/**
 * A construction-scoped node id.
 */
message ConstructionNodeId {
  /**
   * The unique id of a history proof construction.
   */
  uint64 construction_id = 1;
  /**
   * The unique id of a node.
   */
  uint64 node_id = 2;
}

/**
 * A node's vote for a particular history proof; either by explicitly
 * giving the proof, or by identifying a node that already voted for it.
 */
message HistoryProofVote {
  oneof vote {
    /**
     * The history proof the submitting node is voting for.
     */
    HistoryProof proof = 1;
    /**
     * The id of another node that already voted for the exact proof
     * the submitting node is voting for.
     */
    uint64 congruent_node_id = 2;
  }
}

/**
 * An assembly of new history in the form of an address book hash and
 * associated metadata.
 */
message History {
  /**
   * The address book hash of the new history.
   */
  bytes address_book_hash = 1;
  /**
   * The metadata associated to the address book.
   */
  bytes metadata = 2;
}

/**
 * A node's signature blessing some new history.
 */
message HistorySignature {
  /**
   * The new history the node is signing.
   */
  History history = 1;
  /**
   * The node's signature on the canonical serialization of
   * the new history.
   */
  bytes signature = 2;
}

/**
 * A signature on some new history recorded at a certain time.
 */
message RecordedHistorySignature {
  /**
   * The time at which the signature was recorded.
   */
  proto.Timestamp signing_time = 1;

  /**
   * The signature on some new history.
   */
  HistorySignature history_signature = 2;
}

