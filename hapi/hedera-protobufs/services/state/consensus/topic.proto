syntax = "proto3";

package proto;

/*-
 * ‌
 * Hedera Network Services Protobuf
 * ​
 * Copyright (C) 2018 - 2023 Hedera Hashgraph, LLC
 * ​
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ‍
 */

import "basic_types.proto";
import "custom_fees.proto";

option java_package = "com.hederahashgraph.api.proto.java";
// <<<pbj.java_package = "com.hedera.hapi.node.state.consensus">>> This comment is special code for setting PBJ Compiler java package
option java_multiple_files = true;

/**
 * Representation of a Hedera Consensus Service topic in the network Merkle tree.
 * 
 * As with all network entities, a topic has a unique entity number, which is usually given along 
 * with the network's shard and realm in the form of a shard.realm.number id.
 * 
 * A topic consists of just two pieces of data:
 *   1. The total number of messages sent to the topic; and,
 *   2. The running hash of all those messages.
 * It also has several metadata elements:
 *   1. A consensus expiration time in seconds since the epoch.
 *   2. (Optional) The number of an auto-renew account, in the same shard and realm as the topic, that 
 *   has signed a transaction allowing the network to use its balance to automatically extend the topic's 
 *   expiration time when it passes.
 *   3. The number of seconds the network should automatically extend the topic's expiration by, if the 
 *   topic has a valid auto-renew account, and is not deleted upon expiration.
 *   4. A boolean marking if the topic has been deleted.
 *   5. A memo string whose UTF-8 encoding is at most 100 bytes.
 *   6. (Optional) An admin key whose signature must be active for the topic's metadata to be updated.
 *   7. (Optional) A submit key whose signature must be active for the topic to receive a message.
 *   8. (Optional) A fee schedule key whose signature must be active for the topic's custom fees to be updated.
 *   9. (Optional) A list of keys that can submit messages without paying custom fees.
 *   10. (Optional) A list of custom fees to be assessed for each message submitted to the topic.
 *   11. (Optional) A list of crypto allowances for the topic.
 *   12. (Optional) A list of fungible token allowances for the topic.
 */
message Topic {
    /**
     * The topic's unique id in the Merkle state.
     */
    TopicID topic_id = 1;
    /**
     * The number of messages sent to the topic.
     */
    int64 sequence_number = 2;
    /**
     * The topic's consensus expiration time in seconds since the epoch.
     */
    int64 expiration_second = 3;
    /**
     * The number of seconds for which the topic will be automatically renewed 
     * upon expiring (if it has a valid auto-renew account).
     */
    int64 auto_renew_period = 4;
    /**
     * The id of the account (if any) that the network will attempt to charge for the
     * topic's auto-renewal upon expiration.
     */
    AccountID auto_renew_account_id = 5;
    /**
     * Whether this topic is deleted.
     */
    bool deleted = 6;
    /**
     * When a topic is created, its running hash is initialized to 48 bytes of binary zeros.
     * For each submitted message, the topic's running hash is then updated to the output
     * of a particular SHA-384 digest whose input data include the previous running hash.
     * 
     * See the TransactionReceipt.proto documentation for an exact description of the
     * data included in the SHA-384 digest used for the update.
     */
    bytes running_hash = 7;
    /**
     * An optional description of the topic with UTF-8 encoding up to 100 bytes.
     */
    string memo = 8;
    /**
     * If present, enforces access control for updating or deleting the topic.
     * A topic without an admin key is immutable.
     */
    Key admin_key = 9;

    /**
     * If present, enforces access control for message submission to the topic.
     */
    Key submit_key = 10;

    /**
     * Access control for update/delete of custom fees.
     * <p>
     * If this field is unset, the current custom fees CANNOT be changed.<br/>
     * If this field is set, that `Key` MUST sign any transaction to update
     * the custom fee schedule for this topic.
     */
    Key fee_schedule_key = 11;

    /**
     * A set of "privileged payer" keys<br/>
     * Keys in this list are permitted to submit messages to this topic without
     * paying custom fees associated with this topic.
     * <p>
     * If a submit transaction is signed by _any_ key included in this set,
     * custom fees SHALL NOT be charged for that transaction.<br/>
     * A `fee_exempt_key_list` MUST NOT contain more than
     * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.<br/>
     * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.<br/>
     * A `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
     * deleted, or non-existent.
     * If not set, there SHALL NOT be any fee-exempt keys.  In particular, the
     * following keys SHALL NOT be implicitly or automatically added to this
     * list: `adminKey`, `submitKey`, `fee_schedule_key`.
     */
    repeated Key fee_exempt_key_list = 12;

    /**
     * A set of custom fee definitions.<br/>
     * These are fees to be assessed for each submit to this topic.
     * <p>
     * If this list is empty, the only fees charged for a submit to this
     * topic SHALL be the network and node fees.<br/>
     * If this list is not empty, each fee defined in this set SHALL
     * be evaluated for each message submitted to this topic, and the
     * resultant total assessed fees SHALL be charged.<br/>
     * If this list is not empty, custom fees defined here SHALL be
     * charged _in addition to_ the base network and node fees.
     */
    repeated ConsensusCustomFee custom_fees = 13;

    /**
     * A list of crypto allowances for this topic.
     * <p>
     * If a submit transaction is submitted by a user with an allowance,
     * the custom fee SHALL be paid with the allowance.<br/>
     * If the allowance is not enough to pay the fee, the transaction SHALL fail.<br/>
     * If an allowance amount is set to 0, the allowance SHALL be removed.<br/>
     * It SHALL contain account identifier for which the allowance is approved,
     * and the amount approved for that account.
     */
    repeated TopicCryptoAllowance crypto_allowances = 14;

    /**
     * A list of fungible token allowances for this topic.
     * <p>
     * If a submit transaction is submitted by a user with an allowance,
     * the custom fee SHALL be payed with the token allowance<br/>
     * If the allowance is not enough to pay the fee, the transaction SHALL fail.<br/>
     * It contains account number for which the allowance is approved to and the token number.<br/>
     * It also contains and the amount approved for that account.
     */
    repeated TopicFungibleTokenAllowance token_allowances = 30;
}

/**
 * Representation of crypto allowance for a topic in the network Merkle tree.
 *
 * A crypto allowance for a topic represents the hbar funds allocated by an account to cover the fees
 * required for submitting messages when the topic is configured with 'custom fees'.
 * This allows the spender to send messages to this topic while utilizing
 * the allocated allowance to cover the associated cost.
 */
message TopicCryptoAllowance {
    /**
     * The account ID of the spender.
     */
    AccountID spender_id = 1;
    /**
     * The total amount of hbar allocated for the allowance.
     */
    uint64 amount = 2;
    /**
     * The amount of hbar allocated per message.
     */
    uint64 amount_per_message = 3;
}

/**
 * Representation of fungible token allowance for a topic in the network Merkle tree.

 * A fungible token allowance for a topic represents the fungible token amounts allocated by an account
 * to cover the fees required for submitting messages when the topic is configured with 'custom fees'.
 * This allows the spender to send messages to this topic while utilizing
 * the allocated fungible token allowance to cover the associated cost.
 */
message TopicFungibleTokenAllowance {
    /**
     * The ID of the fungible token.
     */
    TokenID token_id = 1;
    /**
     * The account ID of the spender.
     */
    AccountID spender_id = 2;
    /**
     * The total amount of fungible tokens allocated for the allowance.
     */
    uint64 amount = 3;
    /**
     * The amount of fungible tokens allocated per message.
     */
    uint64 amount_per_message = 4;
}
