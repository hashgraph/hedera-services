/*
 * Copyright (C) 2021-2022 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.hedera.services.store.contracts.precompile.codec;

import static com.hedera.services.store.contracts.precompile.HTSPrecompiledContract.HTS_PRECOMPILED_CONTRACT_ADDRESS;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.recipientAddress;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.senderAddress;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.tokenMerkleId;
import static com.hederahashgraph.api.proto.java.ResponseCodeEnum.INVALID_EXPIRATION_TIME;
import static com.hederahashgraph.api.proto.java.ResponseCodeEnum.INVALID_TOKEN_ID;
import static com.hederahashgraph.api.proto.java.ResponseCodeEnum.SUCCESS;
import static com.hederahashgraph.api.proto.java.ResponseCodeEnum.TREASURY_MUST_OWN_BURNED_NFT;
import static org.junit.jupiter.api.Assertions.assertEquals;

import com.esaulpaugh.headlong.abi.Tuple;
import com.esaulpaugh.headlong.abi.TupleType;
import com.google.protobuf.ByteString;
import com.hedera.services.utils.EntityIdUtils;
import com.hederahashgraph.api.proto.java.AccountID;
import com.hederahashgraph.api.proto.java.ContractID;
import com.hederahashgraph.api.proto.java.CustomFee;
import com.hederahashgraph.api.proto.java.Duration;
import com.hederahashgraph.api.proto.java.FixedFee;
import com.hederahashgraph.api.proto.java.Fraction;
import com.hederahashgraph.api.proto.java.FractionalFee;
import com.hederahashgraph.api.proto.java.Key;
import com.hederahashgraph.api.proto.java.NftID;
import com.hederahashgraph.api.proto.java.RoyaltyFee;
import com.hederahashgraph.api.proto.java.Timestamp;
import com.hederahashgraph.api.proto.java.TokenFreezeStatus;
import com.hederahashgraph.api.proto.java.TokenInfo;
import com.hederahashgraph.api.proto.java.TokenNftInfo;
import com.hederahashgraph.api.proto.java.TokenSupplyType;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import org.apache.tuweni.bytes.Bytes;
import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.evm.log.Log;
import org.hyperledger.besu.evm.log.LogTopic;
import org.junit.jupiter.api.Test;

class EncodingFacadeTest {
    private final EncodingFacade subject = new EncodingFacade();

    private static final Bytes RETURN_FUNGIBLE_MINT_FOR_10_TOKENS =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000016"
                        + "0000000000000000000000000000000000000000000000000000000000"
                        + "00000a0000000000000000000000000000000000000000000000000000"
                        + "0000000000600000000000000000000000000000000000000000000000000000000000000000");
    private static final Bytes RETURN_NON_FUNGIBLE_MINT_FOR_2_TOKENS =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000016"
                        + "0000000000000000000000000000000000000000000000000000000000"
                        + "0000020000000000000000000000000000000000000000000000000000"
                        + "00000000006000000000000000000000000000000000000000000000000"
                        + "00000000000000002000000000000000000000000000000000000000000"
                        + "00000000000000000000010000000000000000000000000000000000000000000000000000000000000002");
    private static final Bytes RETURN_BURN_FOR_49_TOKENS =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000016"
                            + "0000000000000000000000000000000000000000000000000000000000000031");
    private static final Bytes MINT_FAILURE_FROM_INVALID_TOKEN_ID =
            Bytes.fromHexString(
                    "0x00000000000000000000000000000000000000000000000000000000000000a7"
                        + "0000000000000000000000000000000000000000000000000000000000"
                        + "0000000000000000000000000000000000000000000000000000000000"
                        + "0000000000600000000000000000000000000000000000000000000000000000000000000000");
    private static final Bytes BURN_FAILURE_FROM_TREASURY_NOT_OWNER =
            Bytes.fromHexString(
                    "0x00000000000000000000000000000000000000000000000000000000000000fc"
                            + "0000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes RETURN_TOTAL_SUPPLY_FOR_50_TOKENS =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000032");

    private static final Bytes RETURN_DECIMALS_10 =
            Bytes.fromHexString(
                    "0x000000000000000000000000000000000000000000000000000000000000000a");

    private static final Bytes RETURN_3 =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000003");

    private static final Bytes RETURN_SUCCESS_3 =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000016"
                            + "0000000000000000000000000000000000000000000000000000000000000003");

    private static final Bytes RETURN_TOKEN_URI_FIRST =
            Bytes.fromHexString(
                    "0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000"
                        + "000000000000000000000000054649525354000000000000000000000000000000000000000000000000000000");

    private static final Bytes RETURN_NAME_TOKENA =
            Bytes.fromHexString(
                    "0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000"
                        + "00000000000000000000006546f6b656e410000000000000000000000000000000000000000000000000000");

    private static final Bytes RETURN_SYMBOL_F =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000"
                        + "00000000000000000000000014600000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes RETURN_TRUE =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000001");

    private static final Bytes RETURN_SUCCESS =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000016");

    private static final Bytes RETURN_SUCCESS_TRUE =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000016"
                            + "0000000000000000000000000000000000000000000000000000000000000001");

    private static final Bytes RETURN_ADDRESS =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000008");

    private static final Bytes RETURN_IS_TOKEN_FROZEN =
            Bytes.fromHexString(
                    "0x00000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000"
                        + "000000000000000000000000001");

    private static final Bytes TRANSFER_EVENT =
            Bytes.fromHexString("ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef");

    private static final Bytes RETURN_CREATE_SUCCESS =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000016"
                            + "0000000000000000000000000000000000000000000000000000000000000008");

    private static final Bytes CREATE_FAILURE_FROM_INVALID_EXPIRATION_TIME =
            Bytes.fromHexString(
                    "0x000000000000000000000000000000000000000000000000000000000000002d"
                            + "0000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes RETURN_GET_TOKEN_INFO =
            Bytes.fromHexString(
                    "0x00000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000000000000000000000000000000000000000000dc00000000000000000000000000000000000000000000000000000000000000ea00000000000000000000000000000000000000000000000000000000000000ec0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000005cc00000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000006347f08b00000000000000000000000000000000000000000000000000000000000005cd000000000000000000000000000000000000000000000000000000000076a70000000000000000000000000000000000000000000000000000000000000000077072696d617279000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008495144584446444500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a554d5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000036000000000000000000000000000000000000000000000000000000000000004a000000000000000000000000000000000000000000000000000000000000005e000000000000000000000000000000000000000000000000000000000000007200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020712681b9868a3e526507d8983486ef14c2626fc7bf170543a0668afa850059a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200a0fde1c21c4b77e8a5fb6ddd68da4a6e6d22d9cfdb7202260f8731cc4a218c40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020a0674fe13373a2bf9492f50435bb852c0ee34d18c205d1d75c746412bd6e6ee90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002088f4700b5519be4cadd40bd81cd4d5e22e3cfb580631348e73e655a9ca358a8c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020696ec08bed92e0987c694971e0c978781a9abc3f7dae06fe5dfaaa68f5c5201e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002095b1ec8737e9baa2b640967f1524103b4f62e3683708a650a985afa9f510d8200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000204c577c652b075ebd79abdfa99501997035aec91b32fd058773625466bdd0ff370000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005ce00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005cc000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000043078303300000000000000000000000000000000000000000000000000000000");

    private static final Bytes RETURN_GET_FUNGIBLE_TOKEN_INFO =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000000000000000000000000000000000000000000dc00000000000000000000000000000000000000000000000000000000000000ea00000000000000000000000000000000000000000000000000000000000000ec0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000005d900000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000006347fc5800000000000000000000000000000000000000000000000000000000000005da000000000000000000000000000000000000000000000000000000000076a700000000000000000000000000000000000000000000000000000000000000000d46756e6769626c65546f6b656e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002465400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a554d5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000036000000000000000000000000000000000000000000000000000000000000004a000000000000000000000000000000000000000000000000000000000000005e000000000000000000000000000000000000000000000000000000000000007200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000201c45a31396a49d6c0925bb17ebc029b7d6abd782e0bf4028e80941be6de323f90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020fd12cf7240b47d9637f6bc4a10a08c5690f2121a209a58f024c4221f43656ba90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002041265a93fe962db8966d413db831e9054770fd3ed2ab9e2d331b17fb5af43c0b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002059558acd3552e3acca2deed0f7b29effd12fdc840921dda5a521637a73c835bf0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020d6d69c2f666dae5eceacd13a209faf9219c8c3b6ab8e124a166814cd60f1f57a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020d765fef98c141e8d249e42aa2933a496f681ee433030122f7c313d0db3c2c52c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020d561aedce1db98aee5b122d44adaddd7731be342ac81f83060d0d2565078ee6000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000028e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005db00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005d9000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000043078303300000000000000000000000000000000000000000000000000000000");

    private static final Bytes RETURN_GET_NON_FUNGIBLE_TOKEN_INFO =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000005a600000000000000000000000000000000000000000000000062d140892443090b0000000000000000000000000000000000000000000000000000000000000f2000000000000000000000000000000000000000000000000000000000000005a7000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000000000000000000000000000000000000000000d200000000000000000000000000000000000000000000000000000000000000d400000000000000000000000000000000000000000000000000000000000000e20000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000005a300000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000006347e78900000000000000000000000000000000000000000000000000000000000005a4000000000000000000000000000000000000000000000000000000000076a70000000000000000000000000000000000000000000000000000000000000000104e6f6e46756e6769626c65546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034e4654000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a554d5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000036000000000000000000000000000000000000000000000000000000000000004a000000000000000000000000000000000000000000000000000000000000005e000000000000000000000000000000000000000000000000000000000000007200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000209e417334d2ea6be459624060e3efdc1b459a884bc6a9c232349af35e9060ed620000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020340868189257acdc22ed04cbd907a49a468fc39d91b8631c906ba8535b1a54c80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020826178afba792a9110b3e777fc69719560cb8168bacd7ee639bc1df28432e4c30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020bd764d0c924274bde9c30e744338c7461383dfc8dcc941b351078a1832d67d4c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200ff48d8d19c9042ca63f03348bb62012a70abe8009312ec9c9cade08b76cbd0b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020347b6e534d1c74ccb4c7076938c42b4233581b90118492c45a5b3365cf7cc7110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020d4a20d46199951ad6d10d38ad72dac59ba425abd692301b1fcf9167686a25157000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000005ab000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005a80000000000000000000000000000000000000000000000000000000000000004307830330000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054669727374000000000000000000000000000000000000000000000000000000");

    private static final Bytes RETURN_GET_FUNGIBLE_TOKEN_CUSTOM_FEES =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005ce00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005cc0000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes RETURN_GET_NON_FUNGIBLE_TOKEN_CUSTOM_FEES =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000005ab000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005a8");

    private static final Bytes RETURN_GET_TOKEN_TYPE =
            Bytes.fromHexString(
                    "0x00000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000001");

    private static final Bytes RETURN_IS_TOKEN =
            Bytes.fromHexString(
                    "0x00000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000001");

    private static final Bytes RETURN_GET_EXPIRY_INFO_FOR_TOKEN =
            Bytes.fromHexString(
                    "0x0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000006368e20c00000000000000000000000000000000000000000000000000000000000008b4000000000000000000000000000000000000000000000000000000000076a700");

    private static final Bytes RETURN_GET_TOKEN_KEY =
            Bytes.fromHexString(
                    "0x000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000209e417334d2ea6be459624060e3efdc1b459a884bc6a9c232349af35e9060ed620000000000000000000000000000000000000000000000000000000000000000");

    final Address logger = Address.fromHexString(HTS_PRECOMPILED_CONTRACT_ADDRESS);

    @Test
    void canEncodeEip1014Address() {
        final var literalEip1014 = "0x8ff8eb31713b9ff374d893d21f3b9eb732a307a5";
        final var besuAddress = Address.fromHexString(literalEip1014);
        final var headlongAddress = EncodingFacade.convertBesuAddressToHeadlongAddress(besuAddress);
        assertEquals(literalEip1014, ("" + headlongAddress).toLowerCase());
    }

    @Test
    void decodeGetTokenInfo() {
        final var tokenInfoBuilder =
                TokenInfo.newBuilder()
                        .setLedgerId(fromHexString("0x03"))
                        .setSupplyTypeValue(TokenSupplyType.FINITE_VALUE)
                        .setSymbol("IQDXDFDE")
                        .setName("primary")
                        .setMemo("JUMP")
                        .setExpiry(Timestamp.newBuilder().setSeconds(1665659019L))
                        .setAutoRenewAccount(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005cd"))))
                        .setAutoRenewPeriod(Duration.newBuilder().setSeconds(7776000L))
                        .setDefaultFreezeStatus(TokenFreezeStatus.Frozen)
                        .setTreasury(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005cc"))))
                        .setTotalSupply(500L)
                        .setMaxSupply(1000L);

        tokenInfoBuilder.setAdminKey(
                initializeKey(
                        new byte[] {
                            113, 38, -127, -71, -122, -118, 62, 82, 101, 7, -40, -104, 52, -122,
                            -17, 20, -62, 98, 111, -57, -65, 23, 5, 67, -96, 102, -118, -6, -123, 0,
                            89, -96
                        }));
        tokenInfoBuilder.setKycKey(
                initializeKey(
                        new byte[] {
                            10, 15, -34, 28, 33, -60, -73, 126, -118, 95, -74, -35, -42, -115, -92,
                            -90, -26, -46, 45, -100, -3, -73, 32, 34, 96, -8, 115, 28, -60, -94, 24,
                            -60
                        }));
        tokenInfoBuilder.setWipeKey(
                initializeKey(
                        new byte[] {
                            -120, -12, 112, 11, 85, 25, -66, 76, -83, -44, 11, -40, 28, -44, -43,
                            -30, 46, 60, -5, 88, 6, 49, 52, -114, 115, -26, 85, -87, -54, 53, -118,
                            -116
                        }));
        tokenInfoBuilder.setPauseKey(
                initializeKey(
                        new byte[] {
                            76, 87, 124, 101, 43, 7, 94, -67, 121, -85, -33, -87, -107, 1, -103,
                            112, 53, -82, -55, 27, 50, -3, 5, -121, 115, 98, 84, 102, -67, -48, -1,
                            55
                        }));
        tokenInfoBuilder.setFeeScheduleKey(
                initializeKey(
                        new byte[] {
                            -107, -79, -20, -121, 55, -23, -70, -94, -74, 64, -106, 127, 21, 36, 16,
                            59, 79, 98, -29, 104, 55, 8, -90, 80, -87, -123, -81, -87, -11, 16, -40,
                            32
                        }));
        tokenInfoBuilder.setFreezeKey(
                initializeKey(
                        new byte[] {
                            -96, 103, 79, -31, 51, 115, -94, -65, -108, -110, -11, 4, 53, -69, -123,
                            44, 14, -29, 77, 24, -62, 5, -47, -41, 92, 116, 100, 18, -67, 110, 110,
                            -23
                        }));
        tokenInfoBuilder.setSupplyKey(
                initializeKey(
                        new byte[] {
                            105, 110, -64, -117, -19, -110, -32, -104, 124, 105, 73, 113, -32, -55,
                            120, 120, 26, -102, -68, 63, 125, -82, 6, -2, 93, -6, -86, 104, -11,
                            -59, 32, 30
                        }));

        final var fixedFee = FixedFee.newBuilder().setAmount(500L);
        final var customFixedFee =
                CustomFee.newBuilder()
                        .setFixedFee(fixedFee)
                        .setFeeCollectorAccountId(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005ce"))))
                        .build();

        final var fraction = Fraction.newBuilder().setNumerator(1).setDenominator(2).build();
        final var fractionalFee =
                FractionalFee.newBuilder()
                        .setFractionalAmount(fraction)
                        .setMinimumAmount(5)
                        .setMaximumAmount(400)
                        .build();
        final var customFractionalFee =
                CustomFee.newBuilder()
                        .setFractionalFee(fractionalFee)
                        .setFeeCollectorAccountId(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005cc"))))
                        .build();

        final var customFees = new ArrayList<CustomFee>();
        customFees.add(customFixedFee);
        customFees.add(customFractionalFee);
        tokenInfoBuilder.addAllCustomFees(customFees);

        final var encodedResult = subject.encodeGetTokenInfo(tokenInfoBuilder.build());
        assertEquals(RETURN_GET_TOKEN_INFO, encodedResult);
    }

    @Test
    void decodeGetFungibleTokenInfo() {
        final var fungibleTokenInfoBuilder =
                TokenInfo.newBuilder()
                        .setLedgerId(fromHexString("0x03"))
                        .setSupplyTypeValue(TokenSupplyType.FINITE_VALUE)
                        .setSymbol("FT")
                        .setName("FungibleToken")
                        .setMemo("JUMP")
                        .setDecimals(1)
                        .setExpiry(Timestamp.newBuilder().setSeconds(1665662040L))
                        .setAutoRenewAccount(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005da"))))
                        .setAutoRenewPeriod(Duration.newBuilder().setSeconds(7776000L))
                        .setDefaultFreezeStatus(TokenFreezeStatus.Frozen)
                        .setTreasury(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005d9"))))
                        .setTotalSupply(500L)
                        .setMaxSupply(1000L);

        fungibleTokenInfoBuilder.setAdminKey(
                initializeKey(
                        new byte[] {
                            28, 69, -93, 19, -106, -92, -99, 108, 9, 37, -69, 23, -21, -64, 41, -73,
                            -42, -85, -41, -126, -32, -65, 64, 40, -24, 9, 65, -66, 109, -29, 35, -7
                        }));
        fungibleTokenInfoBuilder.setKycKey(
                initializeKey(
                        new byte[] {
                            -3, 18, -49, 114, 64, -76, 125, -106, 55, -10, -68, 74, 16, -96, -116,
                            86, -112, -14, 18, 26, 32, -102, 88, -16, 36, -60, 34, 31, 67, 101, 107,
                            -87
                        }));
        fungibleTokenInfoBuilder.setWipeKey(
                initializeKey(
                        new byte[] {
                            89, 85, -118, -51, 53, 82, -29, -84, -54, 45, -18, -48, -9, -78, -98,
                            -1, -47, 47, -36, -124, 9, 33, -35, -91, -91, 33, 99, 122, 115, -56, 53,
                            -65
                        }));
        fungibleTokenInfoBuilder.setPauseKey(
                initializeKey(
                        new byte[] {
                            -43, 97, -82, -36, -31, -37, -104, -82, -27, -79, 34, -44, 74, -38, -35,
                            -41, 115, 27, -29, 66, -84, -127, -8, 48, 96, -48, -46, 86, 80, 120,
                            -18, 96
                        }));
        fungibleTokenInfoBuilder.setFeeScheduleKey(
                initializeKey(
                        new byte[] {
                            -41, 101, -2, -7, -116, 20, 30, -115, 36, -98, 66, -86, 41, 51, -92,
                            -106, -10, -127, -18, 67, 48, 48, 18, 47, 124, 49, 61, 13, -77, -62,
                            -59, 44
                        }));
        fungibleTokenInfoBuilder.setFreezeKey(
                initializeKey(
                        new byte[] {
                            65, 38, 90, -109, -2, -106, 45, -72, -106, 109, 65, 61, -72, 49, -23, 5,
                            71, 112, -3, 62, -46, -85, -98, 45, 51, 27, 23, -5, 90, -12, 60, 11
                        }));
        fungibleTokenInfoBuilder.setSupplyKey(
                initializeKey(
                        new byte[] {
                            -42, -42, -100, 47, 102, 109, -82, 94, -50, -84, -47, 58, 32, -97, -81,
                            -110, 25, -56, -61, -74, -85, -114, 18, 74, 22, 104, 20, -51, 96, -15,
                            -11, 122
                        }));

        final var fixedFee = FixedFee.newBuilder().setAmount(654L);
        final var customFixedFee =
                CustomFee.newBuilder()
                        .setFixedFee(fixedFee)
                        .setFeeCollectorAccountId(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005db"))))
                        .build();

        final var fraction = Fraction.newBuilder().setNumerator(1).setDenominator(2).build();
        final var fractionalFee =
                FractionalFee.newBuilder()
                        .setFractionalAmount(fraction)
                        .setMinimumAmount(5)
                        .setMaximumAmount(400)
                        .build();
        final var customFractionalFee =
                CustomFee.newBuilder()
                        .setFractionalFee(fractionalFee)
                        .setFeeCollectorAccountId(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005d9"))))
                        .build();

        final var customFees = new ArrayList<CustomFee>();
        customFees.add(customFixedFee);
        customFees.add(customFractionalFee);
        fungibleTokenInfoBuilder.addAllCustomFees(customFees);

        final var encodedResult =
                subject.encodeGetFungibleTokenInfo(fungibleTokenInfoBuilder.build());
        assertEquals(RETURN_GET_FUNGIBLE_TOKEN_INFO, encodedResult);
    }

    @Test
    void decodeGetNonFungibleTokenInfo() {
        final var tokenInfoBuilder =
                TokenInfo.newBuilder()
                        .setLedgerId(fromHexString("0x03"))
                        .setSupplyTypeValue(TokenSupplyType.FINITE_VALUE)
                        .setTokenId(tokenMerkleId)
                        .setSymbol("NFT")
                        .setName("NonFungibleToken")
                        .setMemo("JUMP")
                        .setExpiry(Timestamp.newBuilder().setSeconds(1665656713L))
                        .setAutoRenewAccount(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005a4"))))
                        .setAutoRenewPeriod(Duration.newBuilder().setSeconds(7776000L))
                        .setDefaultFreezeStatus(TokenFreezeStatus.Frozen)
                        .setTreasury(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005a3"))))
                        .setTotalSupply(1L)
                        .setMaxSupply(10L);

        tokenInfoBuilder.setAdminKey(
                initializeKey(
                        new byte[] {
                            -98, 65, 115, 52, -46, -22, 107, -28, 89, 98, 64, 96, -29, -17, -36, 27,
                            69, -102, -120, 75, -58, -87, -62, 50, 52, -102, -13, 94, -112, 96, -19,
                            98
                        }));
        tokenInfoBuilder.setKycKey(
                initializeKey(
                        new byte[] {
                            52, 8, 104, 24, -110, 87, -84, -36, 34, -19, 4, -53, -39, 7, -92, -102,
                            70, -113, -61, -99, -111, -72, 99, 28, -112, 107, -88, 83, 91, 26, 84,
                            -56
                        }));
        tokenInfoBuilder.setWipeKey(
                initializeKey(
                        new byte[] {
                            -67, 118, 77, 12, -110, 66, 116, -67, -23, -61, 14, 116, 67, 56, -57,
                            70, 19, -125, -33, -56, -36, -55, 65, -77, 81, 7, -118, 24, 50, -42,
                            125, 76
                        }));
        tokenInfoBuilder.setPauseKey(
                initializeKey(
                        new byte[] {
                            -44, -94, 13, 70, 25, -103, 81, -83, 109, 16, -45, -118, -41, 45, -84,
                            89, -70, 66, 90, -67, 105, 35, 1, -79, -4, -7, 22, 118, -122, -94, 81,
                            87
                        }));
        tokenInfoBuilder.setFeeScheduleKey(
                initializeKey(
                        new byte[] {
                            52, 123, 110, 83, 77, 28, 116, -52, -76, -57, 7, 105, 56, -60, 43, 66,
                            51, 88, 27, -112, 17, -124, -110, -60, 90, 91, 51, 101, -49, 124, -57,
                            17
                        }));
        tokenInfoBuilder.setFreezeKey(
                initializeKey(
                        new byte[] {
                            -126, 97, 120, -81, -70, 121, 42, -111, 16, -77, -25, 119, -4, 105, 113,
                            -107, 96, -53, -127, 104, -70, -51, 126, -26, 57, -68, 29, -14, -124,
                            50, -28, -61
                        }));
        tokenInfoBuilder.setSupplyKey(
                initializeKey(
                        new byte[] {
                            15, -12, -115, -115, 25, -55, 4, 44, -90, 63, 3, 52, -117, -74, 32, 18,
                            -89, 10, -66, -128, 9, 49, 46, -55, -55, -54, -34, 8, -73, 108, -67, 11
                        }));

        final var customFees = new ArrayList<CustomFee>();

        final var fallbackFee =
                FixedFee.newBuilder()
                        .setAmount(100L)
                        .setDenominatingTokenId(
                                EntityIdUtils.tokenIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005ab"))))
                        .build();
        final var fraction = Fraction.newBuilder().setNumerator(1L).setDenominator(2L).build();
        final var royaltyFee =
                RoyaltyFee.newBuilder()
                        .setExchangeValueFraction(fraction)
                        .setFallbackFee(fallbackFee)
                        .build();
        final var customRoyaltyFee =
                CustomFee.newBuilder()
                        .setRoyaltyFee(royaltyFee)
                        .setFeeCollectorAccountId(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005a8"))))
                        .build();
        customFees.add(customRoyaltyFee);
        tokenInfoBuilder.addAllCustomFees(customFees);

        final var nftInfoBuilder =
                TokenNftInfo.newBuilder()
                        .setAccountID(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005a6"))))
                        .setSpenderId(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005a7"))))
                        .setNftID(
                                NftID.newBuilder()
                                        .setSerialNumber(1L)
                                        .setTokenID(tokenMerkleId)
                                        .build())
                        .setMetadata(ByteString.copyFromUtf8("First"))
                        .setCreationTime(Timestamp.newBuilder().setSeconds(7120543443612535051L))
                        .build();

        final var encodedResult =
                subject.encodeGetNonFungibleTokenInfo(tokenInfoBuilder.build(), nftInfoBuilder);
        assertEquals(RETURN_GET_NON_FUNGIBLE_TOKEN_INFO, encodedResult);
    }

    @Test
    void decodeGetFungibleTokenCustomFees() {
        final var fixedFee = FixedFee.newBuilder().setAmount(500L);
        final var customFixedFee =
                CustomFee.newBuilder()
                        .setFixedFee(fixedFee)
                        .setFeeCollectorAccountId(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005ce"))))
                        .build();

        final var fraction = Fraction.newBuilder().setNumerator(1).setDenominator(2).build();
        final var fractionalFee =
                FractionalFee.newBuilder()
                        .setFractionalAmount(fraction)
                        .setMinimumAmount(5)
                        .setMaximumAmount(400)
                        .build();
        final var customFractionalFee =
                CustomFee.newBuilder()
                        .setFractionalFee(fractionalFee)
                        .setFeeCollectorAccountId(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005cc"))))
                        .build();

        final var customFees = new ArrayList<CustomFee>();
        customFees.add(customFixedFee);
        customFees.add(customFractionalFee);

        final var encodedResult = subject.encodeTokenGetCustomFees(customFees);
        assertEquals(RETURN_GET_FUNGIBLE_TOKEN_CUSTOM_FEES, encodedResult);
    }

    @Test
    void decodeGetNonFungibleTokenCustomFees() {
        final var customFees = new ArrayList<CustomFee>();

        final var fallbackFee =
                FixedFee.newBuilder()
                        .setAmount(100L)
                        .setDenominatingTokenId(
                                EntityIdUtils.tokenIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005ab"))))
                        .build();
        final var fraction = Fraction.newBuilder().setNumerator(1L).setDenominator(2L).build();
        final var royaltyFee =
                RoyaltyFee.newBuilder()
                        .setExchangeValueFraction(fraction)
                        .setFallbackFee(fallbackFee)
                        .build();
        final var customRoyaltyFee =
                CustomFee.newBuilder()
                        .setRoyaltyFee(royaltyFee)
                        .setFeeCollectorAccountId(
                                EntityIdUtils.accountIdFromEvmAddress(
                                        Address.wrap(
                                                Bytes.fromHexString(
                                                        "0x00000000000000000000000000000000000005a8"))))
                        .build();
        customFees.add(customRoyaltyFee);

        final var encodedResult = subject.encodeTokenGetCustomFees(customFees);
        assertEquals(RETURN_GET_NON_FUNGIBLE_TOKEN_CUSTOM_FEES, encodedResult);
    }

    @Test
    void decodeReturnResultForFungibleMint() {
        final var decodedResult = subject.encodeMintSuccess(10, null);
        assertEquals(RETURN_FUNGIBLE_MINT_FOR_10_TOKENS, decodedResult);
    }

    @Test
    void decodeReturnResultForNonFungibleMint() {
        final var decodedResult = subject.encodeMintSuccess(2, new long[] {1, 2});
        assertEquals(RETURN_NON_FUNGIBLE_MINT_FOR_2_TOKENS, decodedResult);
    }

    @Test
    void decodeReturnResultForBurn() {
        final var decodedResult = subject.encodeBurnSuccess(49);
        assertEquals(RETURN_BURN_FOR_49_TOKENS, decodedResult);
    }

    @Test
    void decodeReturnResultForCreateSuccess() {
        final var decodedResult = subject.encodeCreateSuccess(senderAddress);
        assertEquals(RETURN_CREATE_SUCCESS, decodedResult);
    }

    @Test
    void decodeReturnResultForCreateFailure() {
        final var decodedResult = subject.encodeCreateFailure(INVALID_EXPIRATION_TIME);
        assertEquals(CREATE_FAILURE_FROM_INVALID_EXPIRATION_TIME, decodedResult);
    }

    @Test
    void decodeReturnResultForTotalSupply() {
        final var decodedResult = subject.encodeTotalSupply(50);
        assertEquals(RETURN_TOTAL_SUPPLY_FOR_50_TOKENS, decodedResult);
    }

    @Test
    void decodeReturnResultForDecimals() {
        final var decodedResult = subject.encodeDecimals(10);
        assertEquals(RETURN_DECIMALS_10, decodedResult);
    }

    @Test
    void decodeReturnResultForBalance() {
        final var decodedResult = subject.encodeBalance(3);
        assertEquals(RETURN_3, decodedResult);
    }

    @Test
    void decodeReturnResultForTokenUri() {
        final var decodedResult = subject.encodeTokenUri("FIRST");
        assertEquals(RETURN_TOKEN_URI_FIRST, decodedResult);
    }

    @Test
    void decodeReturnResultForName() {
        final var decodedResult = subject.encodeName("TokenA");
        assertEquals(RETURN_NAME_TOKENA, decodedResult);
    }

    @Test
    void decodeReturnResultForSymbol() {
        final var decodedResult = subject.encodeSymbol("F");
        assertEquals(RETURN_SYMBOL_F, decodedResult);
    }

    @Test
    void decodeReturnResultForTransfer() {
        final var decodedResult = subject.encodeEcFungibleTransfer(true);
        assertEquals(RETURN_TRUE, decodedResult);
    }

    @Test
    void decodeReturnResultForApproveERC() {
        final var decodedResult = subject.encodeApprove(true);
        assertEquals(RETURN_TRUE, decodedResult);
    }

    @Test
    void decodeReturnResultForApproveHAPI() {
        final var decodedResult = subject.encodeApprove(SUCCESS.getNumber(), true);
        assertEquals(RETURN_SUCCESS_TRUE, decodedResult);
    }

    @Test
    void decodeReturnResultForApproveNFTHAPI() {
        final var decodedResult = subject.encodeApproveNFT(SUCCESS.getNumber());
        assertEquals(RETURN_SUCCESS, decodedResult);
    }

    @Test
    void decodeReturnResultForIsApprovedForAllERC() {
        final var decodedResult = subject.encodeIsApprovedForAll(true);
        assertEquals(RETURN_TRUE, decodedResult);
    }

    @Test
    void decodeReturnResultForIsApprovedForAllHAPI() {
        final var decodedResult = subject.encodeIsApprovedForAll(SUCCESS.getNumber(), true);
        assertEquals(RETURN_SUCCESS_TRUE, decodedResult);
    }

    @Test
    void decodeReturnResultForAllowanceERC() {
        final var decodedResult = subject.encodeAllowance(3);
        assertEquals(RETURN_3, decodedResult);
    }

    @Test
    void decodeReturnResultForAllowanceHAPI() {
        final var decodedResult = subject.encodeAllowance(SUCCESS.getNumber(), 3);
        assertEquals(RETURN_SUCCESS_3, decodedResult);
    }

    @Test
    void decodeReturnResultForGetApprovedERC() {
        final var decodedResult = subject.encodeGetApproved(senderAddress);
        assertEquals(RETURN_ADDRESS, decodedResult);
    }

    @Test
    void decodeReturnResultForGetApprovedHAPI() {
        final var decodedResult = subject.encodeGetApproved(SUCCESS.getNumber(), senderAddress);
        assertEquals(RETURN_CREATE_SUCCESS, decodedResult);
    }

    @Test
    void decodeReturnResultForIsKyc() {
        final var decodedResult = subject.encodeIsKyc(true);
        assertEquals(RETURN_SUCCESS_TRUE, decodedResult);
    }

    @Test
    void decodeReturnResultForGetTokenDefaultFreezeStatus() {
        final var decodedResult = subject.encodeGetTokenDefaultFreezeStatus(true);
        assertEquals(RETURN_SUCCESS_TRUE, decodedResult);
    }

    @Test
    void decodeReturnResultForGetTokenDefaultKycStatus() {
        final var decodedResult = subject.encodeGetTokenDefaultKycStatus(true);
        assertEquals(RETURN_SUCCESS_TRUE, decodedResult);
    }

    @Test
    void decodeReturnResultForOwner() {
        final var decodedResult = subject.encodeOwner(senderAddress);
        assertEquals(RETURN_ADDRESS, decodedResult);
    }

    @Test
    void decodeReturnResultForIsFrozen() {
        final var decodedResult = subject.encodeIsFrozen(true);
        assertEquals(RETURN_IS_TOKEN_FROZEN, decodedResult);
    }

    @Test
    void decodeReturnResultForIsToken() {
        final var decodedResult = subject.encodeIsToken(true);
        assertEquals(RETURN_IS_TOKEN, decodedResult);
    }

    @Test
    void decodeReturnResultForGetTokenType() {
        final var decodedResult = subject.encodeGetTokenType(1);
        assertEquals(RETURN_GET_TOKEN_TYPE, decodedResult);
    }

    @Test
    void decodeGetTokenKey() {
        KeyValueWrapper wrapper =
                new KeyValueWrapper(
                        false,
                        ContractID.getDefaultInstance(),
                        new byte[] {
                            -98, 65, 115, 52, -46, -22, 107, -28, 89, 98, 64, 96, -29, -17, -36, 27,
                            69, -102, -120, 75, -58, -87, -62, 50, 52, -102, -13, 94, -112, 96, -19,
                            98
                        },
                        new byte[0],
                        ContractID.getDefaultInstance());
        final var decodedResult = subject.encodeGetTokenKey(wrapper);
        assertEquals(RETURN_GET_TOKEN_KEY, decodedResult);
    }

    @Test
    void logBuilderWithTopics() {
        final var log =
                EncodingFacade.LogBuilder.logBuilder()
                        .forLogger(logger)
                        .forEventSignature(TRANSFER_EVENT)
                        .forIndexedArgument(senderAddress)
                        .forIndexedArgument(recipientAddress)
                        .build();

        final List<LogTopic> topics = new ArrayList<>();
        topics.add(
                LogTopic.wrap(
                        Bytes.fromHexString(
                                "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef")));
        topics.add(
                LogTopic.wrap(
                        Bytes.fromHexString(
                                "0x0000000000000000000000000000000000000000000000000000000000000008")));
        topics.add(
                LogTopic.wrap(
                        Bytes.fromHexString(
                                "0x0000000000000000000000000000000000000000000000000000000000000006")));

        assertEquals(new Log(logger, Bytes.EMPTY, topics), log);
    }

    @Test
    void logBuilderWithTopicsWithDifferentTypes() {
        final var log =
                EncodingFacade.LogBuilder.logBuilder()
                        .forLogger(logger)
                        .forEventSignature(TRANSFER_EVENT)
                        .forIndexedArgument(senderAddress)
                        .forIndexedArgument(20L)
                        .forIndexedArgument(BigInteger.valueOf(20))
                        .forIndexedArgument(Boolean.TRUE)
                        .forIndexedArgument(false)
                        .build();

        final List<LogTopic> topics = new ArrayList<>();
        topics.add(
                LogTopic.wrap(
                        Bytes.fromHexString(
                                "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef")));
        topics.add(
                LogTopic.wrap(
                        Bytes.fromHexString(
                                "0x0000000000000000000000000000000000000000000000000000000000000008")));
        topics.add(
                LogTopic.wrap(
                        Bytes.fromHexString(
                                "0x0000000000000000000000000000000000000000000000000000000000000014")));
        topics.add(
                LogTopic.wrap(
                        Bytes.fromHexString(
                                "0x0000000000000000000000000000000000000000000000000000000000000014")));
        topics.add(
                LogTopic.wrap(
                        Bytes.fromHexString(
                                "0x0000000000000000000000000000000000000000000000000000000000000001")));
        topics.add(
                LogTopic.wrap(
                        Bytes.fromHexString(
                                "0x0000000000000000000000000000000000000000000000000000000000000000")));

        assertEquals(new Log(logger, Bytes.EMPTY, topics), log);
    }

    @Test
    void logBuilderWithData() {
        final var tupleType = TupleType.parse("(address,uint256,uint256,bool,bool)");
        final var log =
                EncodingFacade.LogBuilder.logBuilder()
                        .forLogger(logger)
                        .forEventSignature(TRANSFER_EVENT)
                        .forDataItem(senderAddress)
                        .forDataItem(9L)
                        .forDataItem(BigInteger.valueOf(9))
                        .forDataItem(Boolean.TRUE)
                        .forDataItem(false)
                        .build();

        final var dataItems = new ArrayList<>();
        dataItems.add(convertBesuAddressToHeadlongAddress(senderAddress));
        dataItems.add(BigInteger.valueOf(9));
        dataItems.add(BigInteger.valueOf(9));
        dataItems.add(true);
        dataItems.add(false);
        final var tuple = Tuple.of(dataItems.toArray());

        final List<LogTopic> topics = new ArrayList<>();
        topics.add(
                LogTopic.wrap(
                        Bytes.fromHexString(
                                "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef")));

        assertEquals(new Log(logger, Bytes.wrap(tupleType.encode(tuple).array()), topics), log);
    }

    @Test
    void createsExpectedMintFailureResult() {
        assertEquals(
                MINT_FAILURE_FROM_INVALID_TOKEN_ID, subject.encodeMintFailure(INVALID_TOKEN_ID));
    }

    @Test
    void createsExpectedBurnFailureResult() {
        assertEquals(
                BURN_FAILURE_FROM_TREASURY_NOT_OWNER,
                subject.encodeBurnFailure(TREASURY_MUST_OWN_BURNED_NFT));
    }

    @Test
    void decodeReturnResultForGetExpiryInfoForTokenSuccess() {
        final var expiry = 1667817996L;
        final var accountID =
                AccountID.newBuilder().setShardNum(0).setRealmNum(0).setAccountNum(2228).build();
        final var autoRenewPeriod = 7776000L;
        final var expiryTokenWrapper = new TokenExpiryWrapper(expiry, accountID, autoRenewPeriod);
        final var decodedResult = subject.encodeGetTokenExpiryInfo(expiryTokenWrapper);
        assertEquals(RETURN_GET_EXPIRY_INFO_FOR_TOKEN, decodedResult);
    }

    private Key initializeKey(final byte[] ed25519KeyValue) {
        return Key.newBuilder().setEd25519(ByteString.copyFrom(ed25519KeyValue)).build();
    }

    private Key initializeKey(final ByteString ed25519KeyValue) {
        return Key.newBuilder().setEd25519(ed25519KeyValue).build();
    }

    private ByteString fromHexString(final String value) {
        return ByteString.copyFrom(Bytes.fromHexString(value).toArray());
    }

    private com.esaulpaugh.headlong.abi.Address convertBesuAddressToHeadlongAddress(
            final Address addressToBeConverted) {
        return com.esaulpaugh.headlong.abi.Address.wrap(
                com.esaulpaugh.headlong.abi.Address.toChecksumAddress(
                        addressToBeConverted.toBigInteger()));
    }
}
