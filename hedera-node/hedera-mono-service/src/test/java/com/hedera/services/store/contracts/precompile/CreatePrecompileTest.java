/*
 * Copyright (C) 2022 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.hedera.services.store.contracts.precompile;

import static com.hedera.services.ledger.properties.AccountProperty.AUTO_RENEW_ACCOUNT_ID;
import static com.hedera.services.ledger.properties.AccountProperty.KEY;
import static com.hedera.services.state.EntityCreator.EMPTY_MEMO;
import static com.hedera.services.store.contracts.precompile.AbiConstants.ABI_ID_CREATE_FUNGIBLE_TOKEN;
import static com.hedera.services.store.contracts.precompile.AbiConstants.ABI_ID_CREATE_FUNGIBLE_TOKEN_V2;
import static com.hedera.services.store.contracts.precompile.AbiConstants.ABI_ID_CREATE_FUNGIBLE_TOKEN_WITH_FEES;
import static com.hedera.services.store.contracts.precompile.AbiConstants.ABI_ID_CREATE_FUNGIBLE_TOKEN_WITH_FEES_V2;
import static com.hedera.services.store.contracts.precompile.AbiConstants.ABI_ID_CREATE_NON_FUNGIBLE_TOKEN;
import static com.hedera.services.store.contracts.precompile.AbiConstants.ABI_ID_CREATE_NON_FUNGIBLE_TOKEN_V2;
import static com.hedera.services.store.contracts.precompile.AbiConstants.ABI_ID_CREATE_NON_FUNGIBLE_TOKEN_WITH_FEES;
import static com.hedera.services.store.contracts.precompile.AbiConstants.ABI_ID_CREATE_NON_FUNGIBLE_TOKEN_WITH_FEES_V2;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.account;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.contractAddr;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.contractAddress;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.createNonFungibleTokenCreateWrapperWithKeys;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.createTokenCreateWrapperWithKeys;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.feeCollector;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.fixedFee;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.invalidFullPrefix;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.invalidSigResult;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.pendingChildConsTime;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.senderAddress;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.successResult;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.timestamp;
import static com.hedera.services.store.contracts.precompile.codec.DecodingFacade.decodeFunctionCall;
import static com.hedera.services.store.contracts.precompile.codec.TokenCreateWrapper.FixedFeeWrapper.FixedFeePayment.USE_CURRENTLY_CREATED_TOKEN;
import static com.hedera.services.store.contracts.precompile.codec.TokenCreateWrapper.FixedFeeWrapper.FixedFeePayment.USE_EXISTING_FUNGIBLE_TOKEN;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.TOKEN_CREATE_FUNGIBLE_DECODER;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.TOKEN_CREATE_FUNGIBLE_SELECTOR;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.TOKEN_CREATE_FUNGIBLE_SELECTOR_V2;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.TOKEN_CREATE_FUNGIBLE_WITH_FEES_DECODER;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.TOKEN_CREATE_FUNGIBLE_WITH_FEES_SELECTOR;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.TOKEN_CREATE_FUNGIBLE_WITH_FEES_SELECTOR_V2;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.TOKEN_CREATE_NON_FUNGIBLE_DECODER;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.TOKEN_CREATE_NON_FUNGIBLE_SELECTOR;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.TOKEN_CREATE_NON_FUNGIBLE_SELECTOR_V2;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.TOKEN_CREATE_NON_FUNGIBLE_WITH_FEES_DECODER;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.TOKEN_CREATE_NON_FUNGIBLE_WITH_FEES_SELECTOR;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.TOKEN_CREATE_NON_FUNGIBLE_WITH_FEES_SELECTOR_V2;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeFixedFees;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeFractionalFees;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeFungibleCreate;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeFungibleCreateV2;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeFungibleCreateWithFees;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeFungibleCreateWithFeesV2;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeNonFungibleCreate;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeNonFungibleCreateV2;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeNonFungibleCreateWithFees;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeNonFungibleCreateWithFeesV2;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeRoyaltyFees;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeTokenCreateWithoutFees;
import static com.hederahashgraph.api.proto.java.ResponseCodeEnum.INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE;
import static com.hederahashgraph.api.proto.java.ResponseCodeEnum.INVALID_SIGNATURE;
import static java.util.function.UnaryOperator.identity;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoInteractions;
import static org.mockito.Mockito.when;

import com.esaulpaugh.headlong.abi.Tuple;
import com.esaulpaugh.headlong.util.Integers;
import com.hedera.services.context.SideEffectsTracker;
import com.hedera.services.context.primitives.StateView;
import com.hedera.services.context.properties.GlobalDynamicProperties;
import com.hedera.services.contracts.sources.TxnAwareEvmSigsVerifier;
import com.hedera.services.exceptions.InvalidTransactionException;
import com.hedera.services.fees.FeeCalculator;
import com.hedera.services.fees.HbarCentExchange;
import com.hedera.services.fees.calculation.UsagePricesProvider;
import com.hedera.services.grpc.marshalling.ImpliedTransfersMarshal;
import com.hedera.services.ledger.TransactionalLedger;
import com.hedera.services.ledger.accounts.ContractAliases;
import com.hedera.services.ledger.properties.AccountProperty;
import com.hedera.services.ledger.properties.NftProperty;
import com.hedera.services.ledger.properties.TokenProperty;
import com.hedera.services.ledger.properties.TokenRelProperty;
import com.hedera.services.legacy.core.jproto.JContractIDKey;
import com.hedera.services.legacy.core.jproto.JECDSASecp256k1Key;
import com.hedera.services.legacy.core.jproto.JEd25519Key;
import com.hedera.services.legacy.core.jproto.JKey;
import com.hedera.services.legacy.core.jproto.TxnReceipt;
import com.hedera.services.pricing.AssetsLoader;
import com.hedera.services.records.RecordsHistorian;
import com.hedera.services.state.expiry.ExpiringCreations;
import com.hedera.services.state.merkle.MerkleToken;
import com.hedera.services.state.merkle.MerkleTokenRelStatus;
import com.hedera.services.state.migration.HederaAccount;
import com.hedera.services.state.migration.UniqueTokenAdapter;
import com.hedera.services.state.submerkle.EntityId;
import com.hedera.services.state.submerkle.ExpirableTxnRecord;
import com.hedera.services.store.AccountStore;
import com.hedera.services.store.TypedTokenStore;
import com.hedera.services.store.contracts.HederaStackedWorldStateUpdater;
import com.hedera.services.store.contracts.UpdateTrackingLedgerAccount;
import com.hedera.services.store.contracts.WorldLedgers;
import com.hedera.services.store.contracts.precompile.codec.EncodingFacade;
import com.hedera.services.store.contracts.precompile.codec.KeyValueWrapper;
import com.hedera.services.store.contracts.precompile.codec.TokenCreateWrapper;
import com.hedera.services.store.contracts.precompile.codec.TokenKeyWrapper;
import com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile;
import com.hedera.services.store.contracts.precompile.utils.PrecompilePricingUtils;
import com.hedera.services.store.models.Id;
import com.hedera.services.store.models.NftId;
import com.hedera.services.txns.token.CreateLogic;
import com.hedera.services.txns.token.validators.CreateChecks;
import com.hedera.services.utils.EntityIdUtils;
import com.hedera.services.utils.accessors.AccessorFactory;
import com.hederahashgraph.api.proto.java.AccountID;
import com.hederahashgraph.api.proto.java.ContractID;
import com.hederahashgraph.api.proto.java.ResponseCodeEnum;
import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;
import com.hederahashgraph.api.proto.java.TokenID;
import com.hederahashgraph.api.proto.java.TransactionBody;
import com.hederahashgraph.api.proto.java.TransactionID;
import com.hederahashgraph.fee.FeeObject;
import java.math.BigInteger;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.UnaryOperator;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.tuweni.bytes.Bytes;
import org.hyperledger.besu.datatypes.Wei;
import org.hyperledger.besu.evm.account.EvmAccount;
import org.hyperledger.besu.evm.frame.BlockValues;
import org.hyperledger.besu.evm.frame.MessageFrame;
import org.hyperledger.besu.evm.gascalculator.GasCalculator;
import org.hyperledger.besu.evm.worldstate.WorldUpdater;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class CreatePrecompileTest {

    @Mock private GlobalDynamicProperties dynamicProperties;
    @Mock private GasCalculator gasCalculator;
    @Mock private MessageFrame frame;
    @Mock private TxnAwareEvmSigsVerifier sigsVerifier;
    @Mock private RecordsHistorian recordsHistorian;
    @Mock private EncodingFacade encoder;
    @Mock private SideEffectsTracker sideEffects;
    @Mock private TransactionBody.Builder mockSynthBodyBuilder;
    @Mock private TokenCreateTransactionBody tokenCreateTransactionBody;
    @Mock private ExpirableTxnRecord.Builder mockRecordBuilder;
    @Mock private SyntheticTxnFactory syntheticTxnFactory;
    @Mock private HederaStackedWorldStateUpdater worldUpdater;
    @Mock private WorldLedgers wrappedLedgers;
    @Mock private TransactionalLedger<NftId, NftProperty, UniqueTokenAdapter> nfts;

    @Mock
    private TransactionalLedger<Pair<AccountID, TokenID>, TokenRelProperty, MerkleTokenRelStatus>
            tokenRels;

    @Mock private TransactionalLedger<AccountID, AccountProperty, HederaAccount> accounts;
    @Mock private TransactionalLedger<TokenID, TokenProperty, MerkleToken> tokens;
    @Mock private ExpiringCreations creator;
    @Mock private ImpliedTransfersMarshal impliedTransfersMarshal;
    @Mock private FeeCalculator feeCalculator;
    @Mock private StateView stateView;
    @Mock private ContractAliases aliases;
    @Mock private UsagePricesProvider resourceCosts;
    @Mock private CreateChecks createChecks;
    @Mock private CreateLogic createLogic;
    @Mock private TypedTokenStore typedTokenStore;
    @Mock private AccountStore accountStore;
    @Mock private InfrastructureFactory infrastructureFactory;
    @Mock private AssetsLoader assetLoader;
    @Mock private HbarCentExchange exchange;
    @Mock private AccessorFactory accessorFactory;

    private HTSPrecompiledContract subject;
    private UpdateTrackingLedgerAccount senderMutableAccount;
    private UpdateTrackingLedgerAccount fundingMutableAccount;
    private MockedStatic<TokenCreatePrecompile> tokenCreatePrecompile;

    private static final long TEST_SERVICE_FEE = 100L;
    private static final long TEST_NODE_FEE = 100_000L;
    private static final long TEST_NETWORK_FEE = 100L;
    private static final long EXPECTED_TINYBARS_REQUIREMENT =
            (TEST_SERVICE_FEE + TEST_NETWORK_FEE + TEST_NODE_FEE)
                    + (TEST_SERVICE_FEE + TEST_NETWORK_FEE + TEST_NODE_FEE) / 5;
    private static final long SENDER_INITIAL_BALANCE = 1_000_000L;
    private static final long FUNDING_ACCOUNT_INITIAL_BALANCE = 123_123L;
    private static final Bytes CREATE_FUNGIBLE_NO_FEES_INPUT =
            Bytes.fromHexString(
                    "0x7812a04b000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c80000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000015b200000000000000000000000000000000000000000000000000000000000000074d79546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034d544b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046d656d6f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes CREATE_FUNGIBLE_NO_FEES_INPUT_V2 =
            Bytes.fromHexString(
                    "c23baeb600000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000007fffffffffffffff0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007fffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000094d79546f6b656e5632000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d544b563200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000066d656d6f56320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes CREATE_FUNGIBLE_WITH_FEES_INPUT =
            Bytes.fromHexString(
                    "0x4c381ae700000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c8000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000005600000000000000000000000000000000000000000000000000000000000000620000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000015b200000000000000000000000000000000000000000000000000000000000000074d79546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034d544b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046d656d6f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000037000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000003");

    private static final Bytes CREATE_FUNGIBLE_WITH_FEES_INPUT_V2 =
            Bytes.fromHexString(
                    "0xb937581a00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000007fffffffffffffff000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000005600000000000000000000000000000000000000000000000000000000000000620000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007fffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000094d79546f6b656e5632000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d544b563200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000066d656d6f56320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001");

    private static final Bytes CREATE_NON_FUNGIBLE_NO_FEES_INPUT =
            Bytes.fromHexString(
                    "0x9dc711e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000037000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000004071b890000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d794e465400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034e4654000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000076e66744d656d6f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes CREATE_NON_FUNGIBLE_NO_FEES_INPUT_V2 =
            Bytes.fromHexString(
                    "0x9c89bb350000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000007fffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000074d794e465456320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054e4654563200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000096e66744d656d6f56320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes CREATE_NON_FUNGIBLE_WITH_FEES_INPUT =
            Bytes.fromHexString(
                    "0x5bc7c0e6000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002a00000000000000000000000000000000000000000000000000000000000000360000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000037000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000004071b890000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d794e465400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034e4654000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000076e66744d656d6f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003f100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000003f1000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes CREATE_NON_FUNGIBLE_WITH_FEES_INPUT_V2 =
            Bytes.fromHexString(
                    "0x457339690000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000000000000000000000000000000000005e0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000007fffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000074d794e465456320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054e4654563200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000096e66744d656d6f56320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002");

    private static final Bytes CREATE_FUNGIBLE_WITH_FEES_INPUT_NULL_ACCOUNTS =
            Bytes.fromHexString(
                    "0x4c381ae700000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c8000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000005600000000000000000000000000000000000000000000000000000000000000620000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000015b200000000000000000000000000000000000000000000000000000000000000074d79546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034d544b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046d656d6f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000037000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes CREATE_NON_FUNGIBLE_WITH_EMPTY_ROYALTY_FEE =
            Bytes.fromHexString(
                    "0x5bc7c0e6000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002a00000000000000000000000000000000000000000000000000000000000000360000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000037000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000004071b890000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d794e465400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034e4654000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000076e66744d656d6f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003f10000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes
            CREATE_FUNGIBLE_NO_FEES_TOKEN_KEY_EXCEEDING_INTEGER_MAX_INVALID_INPUT =
                    Bytes.fromHexString(
                            "0x7812a04b000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c80000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000003f400000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034d544b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046d656d6f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000008000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003f400000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

    @BeforeEach
    void setUp() {
        PrecompilePricingUtils precompilePricingUtils =
                new PrecompilePricingUtils(
                        assetLoader,
                        exchange,
                        () -> feeCalculator,
                        resourceCosts,
                        stateView,
                        accessorFactory);
        subject =
                new HTSPrecompiledContract(
                        dynamicProperties,
                        gasCalculator,
                        recordsHistorian,
                        sigsVerifier,
                        encoder,
                        syntheticTxnFactory,
                        creator,
                        impliedTransfersMarshal,
                        () -> feeCalculator,
                        stateView,
                        precompilePricingUtils,
                        infrastructureFactory);

        tokenCreatePrecompile = Mockito.mockStatic(TokenCreatePrecompile.class);
    }

    @AfterEach
    void closeMocks() {
        tokenCreatePrecompile.close();
    }

    @Test
    void gasAndValueRequirementCalculationWorksAsExpected() {
        // given
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(dynamicProperties.isHTSPrecompileCreateEnabled()).willReturn(true);
        given(frame.getWorldUpdater()).willReturn(worldUpdater);
        given(frame.getRemainingGas()).willReturn(100_000L);
        Optional<WorldUpdater> parent = Optional.of(worldUpdater);
        given(worldUpdater.parentUpdater()).willReturn(parent);
        given(worldUpdater.wrappedTrackingLedgers(any())).willReturn(wrappedLedgers);
        givenValidGasCalculation();
        given(dynamicProperties.isHTSPrecompileCreateEnabled()).willReturn(true);
        given(frame.getWorldUpdater()).willReturn(worldUpdater);
        given(worldUpdater.wrappedTrackingLedgers(any())).willReturn(wrappedLedgers);
        given(wrappedLedgers.accounts()).willReturn(accounts);
        given(frame.getSenderAddress()).willReturn(senderAddress);
        Bytes pretendArguments = Bytes.of(Integers.toBytes(ABI_ID_CREATE_FUNGIBLE_TOKEN));
        final TokenCreateWrapper wrapper = createTokenCreateWrapperWithKeys(List.of());
        tokenCreatePrecompile.when(() -> decodeFungibleCreate(any(), any())).thenReturn(wrapper);
        given(mockSynthBodyBuilder.build())
                .willReturn(
                        TransactionBody.newBuilder()
                                .setTokenCreation(tokenCreateTransactionBody)
                                .build());
        given(mockSynthBodyBuilder.setTransactionID(any(TransactionID.class)))
                .willReturn(mockSynthBodyBuilder);
        given(syntheticTxnFactory.createTokenCreate(wrapper)).willReturn(mockSynthBodyBuilder);

        subject.compute(pretendArguments, frame);

        // then
        assertEquals(
                subject.getPrecompile().getMinimumFeeInTinybars(timestamp),
                subject.gasRequirement(pretendArguments));
        final var tinyBarsRequirement =
                EXPECTED_TINYBARS_REQUIREMENT
                        - subject.getPrecompile().getMinimumFeeInTinybars(timestamp);
        assertEquals(
                SENDER_INITIAL_BALANCE - tinyBarsRequirement,
                senderMutableAccount.getBalance().toLong());
        assertEquals(
                FUNDING_ACCOUNT_INITIAL_BALANCE + tinyBarsRequirement,
                fundingMutableAccount.getBalance().toLong());
    }

    @Test
    void gasAndValueRequirementThrowsWhenValueIsNotSufficient() {
        // given
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(dynamicProperties.isHTSPrecompileCreateEnabled()).willReturn(true);
        given(frame.getWorldUpdater()).willReturn(worldUpdater);
        Optional<WorldUpdater> parent = Optional.of(worldUpdater);
        given(worldUpdater.wrappedTrackingLedgers(any())).willReturn(wrappedLedgers);
        given(wrappedLedgers.accounts()).willReturn(accounts);

        given(frame.getSenderAddress()).willReturn(senderAddress);
        Bytes pretendArguments = Bytes.of(Integers.toBytes(ABI_ID_CREATE_FUNGIBLE_TOKEN));
        final TokenCreateWrapper wrapper = createTokenCreateWrapperWithKeys(List.of());
        tokenCreatePrecompile.when(() -> decodeFungibleCreate(any(), any())).thenReturn(wrapper);
        given(mockSynthBodyBuilder.build())
                .willReturn(
                        TransactionBody.newBuilder()
                                .setTokenCreation(tokenCreateTransactionBody)
                                .build());
        given(mockSynthBodyBuilder.setTransactionID(any(TransactionID.class)))
                .willReturn(mockSynthBodyBuilder);
        given(syntheticTxnFactory.createTokenCreate(wrapper)).willReturn(mockSynthBodyBuilder);
        given(feeCalculator.computeFee(any(), any(), any(), any()))
                .willReturn(new FeeObject(100_000L, 100_000L, 100_000L));
        given(feeCalculator.estimatedGasPriceInTinybars(any(), any())).willReturn(1L);
        given(frame.getValue()).willReturn(Wei.of(1_000L));
        final var blockValuesMock = mock(BlockValues.class);
        given(frame.getBlockValues()).willReturn(blockValuesMock);
        given(blockValuesMock.getTimestamp()).willReturn(timestamp.getSeconds());

        subject.prepareFields(frame);
        subject.prepareComputation(pretendArguments, a -> a);

        final var precompile = subject.getPrecompile();
        assertThrows(InvalidTransactionException.class, () -> precompile.handleSentHbars(frame));

        // then
        Mockito.verifyNoMoreInteractions(syntheticTxnFactory);
    }

    @Test
    void createFungibleHappyPathWorks() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var tokenCreateWrapper =
                createTokenCreateWrapperWithKeys(
                        List.of(
                                new TokenKeyWrapper(
                                        1,
                                        new KeyValueWrapper(
                                                false,
                                                EntityIdUtils.contractIdFromEvmAddress(
                                                        contractAddress),
                                                new byte[] {},
                                                new byte[] {},
                                                null)),
                                new TokenKeyWrapper(
                                        8,
                                        new KeyValueWrapper(
                                                false,
                                                null,
                                                new byte[] {},
                                                new byte[] {},
                                                EntityIdUtils.contractIdFromEvmAddress(
                                                        contractAddress)))));
        Bytes pretendArguments = Bytes.of(Integers.toBytes(ABI_ID_CREATE_FUNGIBLE_TOKEN));
        tokenCreatePrecompile
                .when(() -> decodeFungibleCreate(eq(pretendArguments), any()))
                .thenReturn(tokenCreateWrapper);

        prepareAndAssertCreateHappyPathSucceeds(tokenCreateWrapper, pretendArguments);
    }

    @Test
    void createNonFungibleHappyPathWorks() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var tokenCreateWrapper =
                createNonFungibleTokenCreateWrapperWithKeys(
                        List.of(
                                new TokenKeyWrapper(
                                        1,
                                        new KeyValueWrapper(
                                                false,
                                                null,
                                                new byte[] {},
                                                new byte
                                                        [JECDSASecp256k1Key
                                                                .ECDSA_SECP256K1_COMPRESSED_KEY_LENGTH],
                                                null))));
        Bytes pretendArguments = Bytes.of(Integers.toBytes(ABI_ID_CREATE_NON_FUNGIBLE_TOKEN));
        tokenCreatePrecompile
                .when(() -> decodeNonFungibleCreate(eq(pretendArguments), any()))
                .thenReturn(tokenCreateWrapper);
        given(wrappedLedgers.accounts()).willReturn(accounts);
        given(accounts.get(any(), eq(AUTO_RENEW_ACCOUNT_ID)))
                .willReturn(EntityId.fromGrpcAccountId(account));
        given(sigsVerifier.cryptoKeyIsActive(any())).willReturn(true);

        prepareAndAssertCreateHappyPathSucceeds(tokenCreateWrapper, pretendArguments);
    }

    @Test
    void createFungibleWithFeesHappyPathWorks() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var tokenCreateWrapper =
                createTokenCreateWrapperWithKeys(
                        List.of(
                                new TokenKeyWrapper(
                                        1,
                                        new KeyValueWrapper(
                                                false,
                                                null,
                                                new byte[] {},
                                                new byte[] {},
                                                EntityIdUtils.contractIdFromEvmAddress(
                                                        contractAddress)))));
        tokenCreateWrapper.setFixedFees(List.of(fixedFee));
        tokenCreateWrapper.setFractionalFees(List.of(HTSTestsUtil.fractionalFee));
        Bytes pretendArguments = Bytes.of(Integers.toBytes(ABI_ID_CREATE_FUNGIBLE_TOKEN_WITH_FEES));
        tokenCreatePrecompile
                .when(() -> decodeFungibleCreateWithFees(eq(pretendArguments), any()))
                .thenReturn(tokenCreateWrapper);

        prepareAndAssertCreateHappyPathSucceeds(tokenCreateWrapper, pretendArguments);
    }

    @Test
    void createNonFungibleWithFeesHappyPathWorks() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var tokenCreateWrapper =
                createNonFungibleTokenCreateWrapperWithKeys(
                        List.of(
                                new TokenKeyWrapper(
                                        1,
                                        new KeyValueWrapper(
                                                true, null, new byte[] {}, new byte[] {}, null))));
        tokenCreateWrapper.setFixedFees(List.of(fixedFee));
        tokenCreateWrapper.setRoyaltyFees(List.of(HTSTestsUtil.royaltyFee));
        Bytes pretendArguments =
                Bytes.of(Integers.toBytes(ABI_ID_CREATE_NON_FUNGIBLE_TOKEN_WITH_FEES));
        given(wrappedLedgers.accounts()).willReturn(accounts);
        given(accounts.get(any(), eq(AUTO_RENEW_ACCOUNT_ID)))
                .willReturn(EntityId.fromGrpcAccountId(account));
        tokenCreatePrecompile
                .when(() -> decodeNonFungibleCreateWithFees(eq(pretendArguments), any()))
                .thenReturn(tokenCreateWrapper);
        given(accounts.get(any(), eq(KEY)))
                .willReturn(
                        new JContractIDKey(
                                EntityIdUtils.contractIdFromEvmAddress(contractAddress)));

        prepareAndAssertCreateHappyPathSucceeds(tokenCreateWrapper, pretendArguments);
    }

    @Test
    void createFungibleV2HappyPathWorks() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var tokenCreateWrapper =
                createTokenCreateWrapperWithKeys(
                        List.of(
                                new TokenKeyWrapper(
                                        1,
                                        new KeyValueWrapper(
                                                false,
                                                EntityIdUtils.contractIdFromEvmAddress(
                                                        contractAddress),
                                                new byte[] {},
                                                new byte[] {},
                                                null)),
                                new TokenKeyWrapper(
                                        8,
                                        new KeyValueWrapper(
                                                false,
                                                null,
                                                new byte[] {},
                                                new byte[] {},
                                                EntityIdUtils.contractIdFromEvmAddress(
                                                        contractAddress)))));
        Bytes pretendArguments = Bytes.of(Integers.toBytes(ABI_ID_CREATE_FUNGIBLE_TOKEN_V2));
        tokenCreatePrecompile
                .when(() -> decodeFungibleCreateV2(eq(pretendArguments), any()))
                .thenReturn(tokenCreateWrapper);

        prepareAndAssertCreateHappyPathSucceeds(tokenCreateWrapper, pretendArguments);
    }

    @Test
    void createFungibleWithFeesV2HappyPathWorks() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var tokenCreateWrapper =
                createTokenCreateWrapperWithKeys(
                        List.of(
                                new TokenKeyWrapper(
                                        1,
                                        new KeyValueWrapper(
                                                false,
                                                null,
                                                new byte[] {},
                                                new byte[] {},
                                                EntityIdUtils.contractIdFromEvmAddress(
                                                        contractAddress)))));
        tokenCreateWrapper.setFixedFees(List.of(fixedFee));
        tokenCreateWrapper.setFractionalFees(List.of(HTSTestsUtil.fractionalFee));
        Bytes pretendArguments =
                Bytes.of(Integers.toBytes(ABI_ID_CREATE_FUNGIBLE_TOKEN_WITH_FEES_V2));
        tokenCreatePrecompile
                .when(() -> decodeFungibleCreateWithFeesV2(eq(pretendArguments), any()))
                .thenReturn(tokenCreateWrapper);

        prepareAndAssertCreateHappyPathSucceeds(tokenCreateWrapper, pretendArguments);
    }

    @Test
    void createNonFungibleV2HappyPathWorks() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var tokenCreateWrapper =
                createNonFungibleTokenCreateWrapperWithKeys(
                        List.of(
                                new TokenKeyWrapper(
                                        1,
                                        new KeyValueWrapper(
                                                false,
                                                null,
                                                new byte[] {},
                                                new byte
                                                        [JECDSASecp256k1Key
                                                                .ECDSA_SECP256K1_COMPRESSED_KEY_LENGTH],
                                                null))));
        Bytes pretendArguments = Bytes.of(Integers.toBytes(ABI_ID_CREATE_NON_FUNGIBLE_TOKEN_V2));
        tokenCreatePrecompile
                .when(() -> decodeNonFungibleCreateV2(eq(pretendArguments), any()))
                .thenReturn(tokenCreateWrapper);
        given(wrappedLedgers.accounts()).willReturn(accounts);
        given(accounts.get(any(), eq(AUTO_RENEW_ACCOUNT_ID)))
                .willReturn(EntityId.fromGrpcAccountId(account));
        given(sigsVerifier.cryptoKeyIsActive(any())).willReturn(true);

        prepareAndAssertCreateHappyPathSucceeds(tokenCreateWrapper, pretendArguments);
    }

    @Test
    void createNonFungibleV2WithFeesHappyPathWorks() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var tokenCreateWrapper =
                createNonFungibleTokenCreateWrapperWithKeys(
                        List.of(
                                new TokenKeyWrapper(
                                        1,
                                        new KeyValueWrapper(
                                                true, null, new byte[] {}, new byte[] {}, null))));
        tokenCreateWrapper.setFixedFees(List.of(fixedFee));
        tokenCreateWrapper.setRoyaltyFees(List.of(HTSTestsUtil.royaltyFee));
        Bytes pretendArguments =
                Bytes.of(Integers.toBytes(ABI_ID_CREATE_NON_FUNGIBLE_TOKEN_WITH_FEES_V2));
        given(wrappedLedgers.accounts()).willReturn(accounts);
        given(accounts.get(any(), eq(AUTO_RENEW_ACCOUNT_ID)))
                .willReturn(EntityId.fromGrpcAccountId(account));
        tokenCreatePrecompile
                .when(() -> decodeNonFungibleCreateWithFeesV2(eq(pretendArguments), any()))
                .thenReturn(tokenCreateWrapper);
        given(accounts.get(any(), eq(KEY)))
                .willReturn(
                        new JContractIDKey(
                                EntityIdUtils.contractIdFromEvmAddress(contractAddress)));

        prepareAndAssertCreateHappyPathSucceeds(tokenCreateWrapper, pretendArguments);
    }

    @Test
    void createFailurePath() {
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        givenMinimalFrameContext();
        givenValidGasCalculation();

        given(wrappedLedgers.accounts()).willReturn(accounts);
        given(aliases.resolveForEvm(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(worldUpdater.aliases()).willReturn(aliases);
        Bytes pretendArguments = Bytes.of(Integers.toBytes(ABI_ID_CREATE_FUNGIBLE_TOKEN));
        final var tokenCreateWrapper =
                createTokenCreateWrapperWithKeys(
                        List.of(
                                new TokenKeyWrapper(
                                        1,
                                        new KeyValueWrapper(
                                                false,
                                                null,
                                                new byte[JEd25519Key.ED25519_BYTE_LENGTH],
                                                new byte[] {},
                                                null))));
        tokenCreatePrecompile
                .when(() -> decodeFungibleCreate(eq(pretendArguments), any()))
                .thenReturn(tokenCreateWrapper);
        given(syntheticTxnFactory.createTokenCreate(tokenCreateWrapper))
                .willReturn(mockSynthBodyBuilder);
        given(mockSynthBodyBuilder.build())
                .willReturn(
                        TransactionBody.newBuilder()
                                .setTokenCreation(tokenCreateTransactionBody)
                                .build());
        given(mockSynthBodyBuilder.setTransactionID(any(TransactionID.class)))
                .willReturn(mockSynthBodyBuilder);
        given(frame.getSenderAddress()).willReturn(senderAddress);
        given(sigsVerifier.hasActiveKey(Mockito.anyBoolean(), any(), any(), any()))
                .willReturn(true);
        final var validator = Mockito.mock(Function.class);
        given(createChecks.validatorForConsTime(any())).willReturn(validator);
        given(validator.apply(any())).willReturn(ResponseCodeEnum.OK);
        given(recordsHistorian.nextFollowingChildConsensusTime()).willReturn(pendingChildConsTime);
        given(sigsVerifier.cryptoKeyIsActive(any(JKey.class)))
                .willThrow(new InvalidTransactionException(INVALID_SIGNATURE));
        given(creator.createUnsuccessfulSyntheticRecord(INVALID_SIGNATURE))
                .willReturn(mockRecordBuilder);
        given(encoder.encodeCreateFailure(INVALID_SIGNATURE)).willReturn(invalidSigResult);
        given(infrastructureFactory.newCreateChecks()).willReturn(createChecks);

        // when:
        final var result = subject.compute(pretendArguments, frame);

        // then:
        assertEquals(invalidSigResult, result);

        verify(creator).createUnsuccessfulSyntheticRecord(INVALID_SIGNATURE);
        verify(createLogic, never())
                .create(
                        pendingChildConsTime.getEpochSecond(),
                        EntityIdUtils.accountIdFromEvmAddress(senderAddress),
                        tokenCreateTransactionBody);
        verify(wrappedLedgers, never()).commit();
        verify(worldUpdater)
                .manageInProgressRecord(recordsHistorian, mockRecordBuilder, mockSynthBodyBuilder);
    }

    @Test
    void createFailsWhenCreateChecksAreNotSuccessful() {
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        givenValidGasCalculation();
        given(frame.getRemainingGas()).willReturn(100_000L);
        given(dynamicProperties.isHTSPrecompileCreateEnabled()).willReturn(true);
        given(frame.getWorldUpdater()).willReturn(worldUpdater);
        Optional<WorldUpdater> parent = Optional.of(worldUpdater);
        given(worldUpdater.parentUpdater()).willReturn(parent);
        given(worldUpdater.wrappedTrackingLedgers(any())).willReturn(wrappedLedgers);
        given(wrappedLedgers.accounts()).willReturn(accounts);
        Bytes pretendArguments = Bytes.of(Integers.toBytes(ABI_ID_CREATE_FUNGIBLE_TOKEN));
        final var tokenCreateWrapper =
                createTokenCreateWrapperWithKeys(
                        List.of(
                                new TokenKeyWrapper(
                                        1,
                                        new KeyValueWrapper(
                                                false,
                                                null,
                                                new byte[JEd25519Key.ED25519_BYTE_LENGTH],
                                                new byte[] {},
                                                null))));
        tokenCreatePrecompile
                .when(() -> decodeFungibleCreate(eq(pretendArguments), any()))
                .thenReturn(tokenCreateWrapper);
        given(mockSynthBodyBuilder.build())
                .willReturn(
                        TransactionBody.newBuilder()
                                .setTokenCreation(tokenCreateTransactionBody)
                                .build());
        given(mockSynthBodyBuilder.setTransactionID(any(TransactionID.class)))
                .willReturn(mockSynthBodyBuilder);
        given(syntheticTxnFactory.createTokenCreate(tokenCreateWrapper))
                .willReturn(mockSynthBodyBuilder);
        given(frame.getSenderAddress()).willReturn(senderAddress);
        final var tokenCreateValidator = Mockito.mock(Function.class);
        given(createChecks.validatorForConsTime(any())).willReturn(tokenCreateValidator);
        given(tokenCreateValidator.apply(any())).willReturn(INVALID_SIGNATURE);
        given(creator.createUnsuccessfulSyntheticRecord(INVALID_SIGNATURE))
                .willReturn(mockRecordBuilder);
        given(encoder.encodeCreateFailure(INVALID_SIGNATURE)).willReturn(invalidSigResult);
        given(infrastructureFactory.newCreateChecks()).willReturn(createChecks);

        // when:
        final var result = subject.compute(pretendArguments, frame);

        // then:
        assertEquals(invalidSigResult, result);

        verify(creator).createUnsuccessfulSyntheticRecord(INVALID_SIGNATURE);
        verify(createLogic, never())
                .create(
                        pendingChildConsTime.getEpochSecond(),
                        EntityIdUtils.accountIdFromEvmAddress(senderAddress),
                        tokenCreateTransactionBody);
        verify(wrappedLedgers, never()).commit();
        verify(worldUpdater)
                .manageInProgressRecord(recordsHistorian, mockRecordBuilder, mockSynthBodyBuilder);
    }

    @Test
    void validateAdminKeySignatureFailsIfKeyIsInvalid() {
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        givenMinimalFrameContext();
        givenValidGasCalculation();
        given(wrappedLedgers.accounts()).willReturn(accounts);
        given(frame.getRemainingGas()).willReturn(100_000L);
        given(dynamicProperties.isHTSPrecompileCreateEnabled()).willReturn(true);
        given(frame.getWorldUpdater()).willReturn(worldUpdater);
        Optional<WorldUpdater> parent = Optional.of(worldUpdater);
        given(worldUpdater.parentUpdater()).willReturn(parent);
        given(worldUpdater.wrappedTrackingLedgers(any())).willReturn(wrappedLedgers);
        given(wrappedLedgers.accounts()).willReturn(accounts);
        Bytes pretendArguments = Bytes.of(Integers.toBytes(ABI_ID_CREATE_FUNGIBLE_TOKEN));
        final var keyValueMock = Mockito.mock(KeyValueWrapper.class);
        when(keyValueMock.getKeyValueType())
                .thenReturn(KeyValueWrapper.KeyValueType.CONTRACT_ID)
                .thenReturn(KeyValueWrapper.KeyValueType.INVALID_KEY);
        final var tokenCreateWrapper =
                createTokenCreateWrapperWithKeys(List.of(new TokenKeyWrapper(1, keyValueMock)));
        tokenCreatePrecompile
                .when(() -> decodeFungibleCreate(eq(pretendArguments), any()))
                .thenReturn(tokenCreateWrapper);
        given(mockSynthBodyBuilder.build())
                .willReturn(
                        TransactionBody.newBuilder()
                                .setTokenCreation(tokenCreateTransactionBody)
                                .build());
        given(mockSynthBodyBuilder.setTransactionID(any(TransactionID.class)))
                .willReturn(mockSynthBodyBuilder);
        given(syntheticTxnFactory.createTokenCreate(tokenCreateWrapper))
                .willReturn(mockSynthBodyBuilder);
        given(frame.getSenderAddress()).willReturn(senderAddress);
        given(sigsVerifier.hasActiveKey(Mockito.anyBoolean(), any(), any(), any()))
                .willReturn(true);
        final var tokenCreateValidator = Mockito.mock(Function.class);
        given(createChecks.validatorForConsTime(any())).willReturn(tokenCreateValidator);
        given(tokenCreateValidator.apply(any())).willReturn(ResponseCodeEnum.OK);
        given(aliases.resolveForEvm(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(worldUpdater.aliases()).willReturn(aliases);
        given(
                        creator.createUnsuccessfulSyntheticRecord(
                                INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE))
                .willReturn(mockRecordBuilder);
        given(encoder.encodeCreateFailure(INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE))
                .willReturn(invalidFullPrefix);
        given(infrastructureFactory.newCreateChecks()).willReturn(createChecks);

        // when:
        final var result = subject.compute(pretendArguments, frame);

        // then:
        assertEquals(invalidFullPrefix, result);

        verify(creator)
                .createUnsuccessfulSyntheticRecord(INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE);
        verify(createLogic, never())
                .create(
                        pendingChildConsTime.getEpochSecond(),
                        EntityIdUtils.accountIdFromEvmAddress(senderAddress),
                        tokenCreateTransactionBody);
        verify(wrappedLedgers, never()).commit();
        verify(worldUpdater)
                .manageInProgressRecord(recordsHistorian, mockRecordBuilder, mockSynthBodyBuilder);
    }

    @Test
    void createReturnsNullAndSetsRevertReasonWhenKeyWithMultipleKeyTypesIsPresent() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var tokenCreateWrapper =
                createTokenCreateWrapperWithKeys(
                        List.of(
                                new TokenKeyWrapper(
                                        1,
                                        new KeyValueWrapper(
                                                false,
                                                EntityIdUtils.contractIdFromEvmAddress(
                                                        contractAddress),
                                                new byte[JEd25519Key.ED25519_BYTE_LENGTH],
                                                new byte[] {},
                                                null))));

        prepareAndAssertRevertReasonIsSetAndNullIsReturned(tokenCreateWrapper);
    }

    @Test
    void createReturnsNullAndSetsRevertReasonsWhenKeyWithNoKeyTypeToApplyToPresent() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var tokenCreateWrapper =
                createTokenCreateWrapperWithKeys(
                        List.of(
                                new TokenKeyWrapper(
                                        0,
                                        new KeyValueWrapper(
                                                false,
                                                EntityIdUtils.contractIdFromEvmAddress(
                                                        contractAddress),
                                                new byte[] {},
                                                new byte[] {},
                                                null)),
                                new TokenKeyWrapper(
                                        1,
                                        new KeyValueWrapper(
                                                false,
                                                null,
                                                new byte[JEd25519Key.ED25519_BYTE_LENGTH],
                                                new byte[] {},
                                                null))));

        prepareAndAssertRevertReasonIsSetAndNullIsReturned(tokenCreateWrapper);
    }

    @Test
    void createReturnsNullAndSetsRevertReasonWhenMultipleKeysForSameKeyTypePresent() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var tokenCreateWrapper =
                createTokenCreateWrapperWithKeys(
                        List.of(
                                new TokenKeyWrapper(
                                        1,
                                        new KeyValueWrapper(
                                                false,
                                                EntityIdUtils.contractIdFromEvmAddress(
                                                        contractAddress),
                                                new byte[] {},
                                                new byte[] {},
                                                null)),
                                new TokenKeyWrapper(
                                        1,
                                        new KeyValueWrapper(
                                                false,
                                                null,
                                                new byte[] {},
                                                new byte[] {},
                                                EntityIdUtils.contractIdFromEvmAddress(
                                                        contractAddress)))));

        prepareAndAssertRevertReasonIsSetAndNullIsReturned(tokenCreateWrapper);
    }

    @Test
    void createReturnsNullAndSetsRevertReasonWhenKeyWithBitBiggerThan6IsSet() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var tokenCreateWrapper =
                createTokenCreateWrapperWithKeys(
                        List.of(
                                new TokenKeyWrapper(
                                        128,
                                        new KeyValueWrapper(
                                                false,
                                                null,
                                                new byte[] {},
                                                new byte[] {},
                                                EntityIdUtils.contractIdFromEvmAddress(
                                                        contractAddress)))));

        prepareAndAssertRevertReasonIsSetAndNullIsReturned(tokenCreateWrapper);
    }

    @Test
    void createReturnsNullAndSetsRevertReasonWhenSenderKeyCannotBeDecoded() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var tokenCreateWrapper = Mockito.mock(TokenCreateWrapper.class);
        given(wrappedLedgers.accounts()).willReturn(accounts);
        final var keyMock = Mockito.mock(JKey.class);
        given(accounts.get(any(), any())).willReturn(keyMock);

        prepareAndAssertRevertReasonIsSetAndNullIsReturned(tokenCreateWrapper);
    }

    @Test
    void createReturnsNullAndSetsRevertReasonWhenInitSupplyIsBiggerThanMaxLong() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var invalidTokenCreate =
                new TokenCreateWrapper(
                        true,
                        "",
                        "",
                        null,
                        "",
                        false,
                        new BigInteger(
                                "9223372036854775809"), // LONG_MAX (9,223,372,036,854,775,807) + 2
                        BigInteger.ZERO,
                        0L,
                        false,
                        Collections.emptyList(),
                        null);

        prepareAndAssertRevertReasonIsSetAndNullIsReturned(invalidTokenCreate);
    }

    @Test
    void createReturnsNullAndSetsRevertReasonWhenDecimalsIsBiggerThanMaxInt() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var invalidTokenCreate =
                new TokenCreateWrapper(
                        true,
                        "",
                        "",
                        null,
                        "",
                        false,
                        BigInteger.ZERO,
                        BigInteger.valueOf(Long.MAX_VALUE),
                        0L,
                        false,
                        Collections.emptyList(),
                        null);

        prepareAndAssertRevertReasonIsSetAndNullIsReturned(invalidTokenCreate);
    }

    @Test
    void createReturnsNullAndSetsRevertReasonWhenInvalidFixedFeeIsPresent() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var invalidTokenCreate = createTokenCreateWrapperWithKeys(Collections.emptyList());
        final var fixedFeeMock = mock(TokenCreateWrapper.FixedFeeWrapper.class);
        given(fixedFeeMock.getFixedFeePayment())
                .willReturn(TokenCreateWrapper.FixedFeeWrapper.FixedFeePayment.INVALID_PAYMENT);
        invalidTokenCreate.setFixedFees(List.of(fixedFeeMock));

        prepareAndAssertRevertReasonIsSetAndNullIsReturned(invalidTokenCreate);
    }

    @Test
    void createReturnsNullAndSetsRevertReasonWhenRoyaltyFeeWithInvalidFallbackFeeIsPresent() {
        // test-specific preparations
        given(infrastructureFactory.newSideEffects()).willReturn(sideEffects);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var invalidTokenCreate = createTokenCreateWrapperWithKeys(Collections.emptyList());
        final var fixedFeeMock = mock(TokenCreateWrapper.FixedFeeWrapper.class);
        given(fixedFeeMock.getFixedFeePayment())
                .willReturn(TokenCreateWrapper.FixedFeeWrapper.FixedFeePayment.INVALID_PAYMENT);
        invalidTokenCreate.setRoyaltyFees(
                List.of(
                        new TokenCreateWrapper.RoyaltyFeeWrapper(1, 2, null, feeCollector),
                        new TokenCreateWrapper.RoyaltyFeeWrapper(
                                1, 2, fixedFeeMock, feeCollector)));

        prepareAndAssertRevertReasonIsSetAndNullIsReturned(invalidTokenCreate);
    }

    @Test
    void decodeFungibleCreateNoFeesInput() {
        final Tuple decodedArguments =
                decodeFunctionCall(
                        CREATE_FUNGIBLE_NO_FEES_INPUT,
                        TOKEN_CREATE_FUNGIBLE_SELECTOR,
                        TOKEN_CREATE_FUNGIBLE_DECODER);
        tokenCreatePrecompile
                .when(() -> decodeFungibleCreate(CREATE_FUNGIBLE_NO_FEES_INPUT, identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeTokenCreateWithoutFees(
                                        decodedArguments.get(0),
                                        true,
                                        decodedArguments.get(1),
                                        decodedArguments.get(2),
                                        identity()))
                .thenCallRealMethod();

        final var decodedInput = decodeFungibleCreate(CREATE_FUNGIBLE_NO_FEES_INPUT, identity());

        assertExpectedFungibleTokenCreateStruct(decodedInput);
        assertEquals(BigInteger.valueOf(200), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(8), decodedInput.getDecimals());
        assertExpectedKeys(decodedInput);
    }

    @Test
    void decodeFungibleCreateWithFeesInput() {
        final Tuple decodedArguments =
                decodeFunctionCall(
                        CREATE_FUNGIBLE_WITH_FEES_INPUT,
                        TOKEN_CREATE_FUNGIBLE_WITH_FEES_SELECTOR,
                        TOKEN_CREATE_FUNGIBLE_WITH_FEES_DECODER);
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeFungibleCreateWithFees(
                                        CREATE_FUNGIBLE_WITH_FEES_INPUT, identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeTokenCreateWithoutFees(
                                        decodedArguments.get(0),
                                        true,
                                        decodedArguments.get(1),
                                        decodedArguments.get(2),
                                        identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(() -> decodeFixedFees(decodedArguments.get(3), identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(() -> decodeFractionalFees(decodedArguments.get(4), identity()))
                .thenCallRealMethod();
        final var decodedInput =
                decodeFungibleCreateWithFees(CREATE_FUNGIBLE_WITH_FEES_INPUT, identity());

        assertExpectedFungibleTokenCreateStruct(decodedInput);
        assertEquals(decodedInput.getInitSupply(), BigInteger.valueOf(200));
        assertEquals(decodedInput.getDecimals(), BigInteger.valueOf(8));
        assertExpectedKeys(decodedInput);

        final var fixedFees = decodedInput.getFixedFees();
        assertEquals(1, fixedFees.size());
        final var fixedFeeWrapper = fixedFees.get(0);
        assertEquals(USE_CURRENTLY_CREATED_TOKEN, fixedFeeWrapper.getFixedFeePayment());
        final var customFee = fixedFeeWrapper.asGrpc();
        assertEquals(4, customFee.getFixedFee().getAmount());
        assertEquals(
                TokenID.newBuilder().setTokenNum(0).setRealmNum(0).setShardNum(0).build(),
                customFee.getFixedFee().getDenominatingTokenId());
        assertEquals(
                AccountID.newBuilder().setAccountNum(1).build(),
                customFee.getFeeCollectorAccountId());

        final var fractionalFees = decodedInput.getFractionalFees();
        assertEquals(1, fractionalFees.size());
        final var fractionalFeeWrapper = fractionalFees.get(0);
        assertEquals(5, fractionalFeeWrapper.numerator());
        assertEquals(6, fractionalFeeWrapper.denominator());
        assertEquals(55, fractionalFeeWrapper.minimumAmount());
        assertEquals(100, fractionalFeeWrapper.maximumAmount());
        assertTrue(fractionalFeeWrapper.netOfTransfers());
        assertEquals(
                AccountID.newBuilder().setAccountNum(3).build(),
                fractionalFeeWrapper.feeCollector());
    }

    @Test
    void decodeNonFungibleCreateNoFeesInput() {
        final Tuple decodedArguments =
                decodeFunctionCall(
                        CREATE_NON_FUNGIBLE_NO_FEES_INPUT,
                        TOKEN_CREATE_NON_FUNGIBLE_SELECTOR,
                        TOKEN_CREATE_NON_FUNGIBLE_DECODER);
        tokenCreatePrecompile
                .when(() -> decodeNonFungibleCreate(CREATE_NON_FUNGIBLE_NO_FEES_INPUT, identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeTokenCreateWithoutFees(
                                        decodedArguments.get(0),
                                        false,
                                        BigInteger.ZERO,
                                        BigInteger.ZERO,
                                        identity()))
                .thenCallRealMethod();
        final var decodedInput =
                decodeNonFungibleCreate(CREATE_NON_FUNGIBLE_NO_FEES_INPUT, identity());

        assertExpectedNonFungibleTokenCreateStruct(decodedInput);
        assertEquals(BigInteger.valueOf(0), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(0), decodedInput.getDecimals());
        assertEquals(0, decodedInput.getTokenKeys().size());
    }

    @Test
    void decodeNonFungibleCreateWithFeesInput() {
        final Tuple decodedArguments =
                decodeFunctionCall(
                        CREATE_NON_FUNGIBLE_WITH_FEES_INPUT,
                        TOKEN_CREATE_NON_FUNGIBLE_WITH_FEES_SELECTOR,
                        TOKEN_CREATE_NON_FUNGIBLE_WITH_FEES_DECODER);
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeNonFungibleCreateWithFees(
                                        CREATE_NON_FUNGIBLE_WITH_FEES_INPUT, identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeTokenCreateWithoutFees(
                                        decodedArguments.get(0),
                                        false,
                                        BigInteger.ZERO,
                                        BigInteger.ZERO,
                                        identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(() -> decodeFixedFees(decodedArguments.get(1), identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(() -> decodeRoyaltyFees(decodedArguments.get(2), identity()))
                .thenCallRealMethod();

        final var decodedInput =
                decodeNonFungibleCreateWithFees(CREATE_NON_FUNGIBLE_WITH_FEES_INPUT, identity());

        assertExpectedNonFungibleTokenCreateStruct(decodedInput);
        assertEquals(BigInteger.valueOf(0), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(0), decodedInput.getDecimals());
        assertEquals(0, decodedInput.getTokenKeys().size());

        final var fixedFees = decodedInput.getFixedFees();
        assertEquals(1, fixedFees.size());
        final var fixedFeeWrapper = fixedFees.get(0);
        assertEquals(USE_EXISTING_FUNGIBLE_TOKEN, fixedFeeWrapper.getFixedFeePayment());
        final var customFee = fixedFeeWrapper.asGrpc();
        assertEquals(4, customFee.getFixedFee().getAmount());
        assertEquals(
                TokenID.newBuilder().setTokenNum(1).build(),
                customFee.getFixedFee().getDenominatingTokenId());
        assertEquals(
                AccountID.newBuilder().setAccountNum(1009).build(),
                customFee.getFeeCollectorAccountId());

        final var royaltyFees = decodedInput.getRoyaltyFees();
        assertEquals(2, royaltyFees.size());
        final var royaltyFeeWrapper = royaltyFees.get(0);
        assertEquals(4, royaltyFeeWrapper.numerator());
        assertEquals(5, royaltyFeeWrapper.denominator());
        final var actualFallbackFee = royaltyFeeWrapper.fallbackFixedFee().asGrpc();
        assertEquals(5, actualFallbackFee.getFixedFee().getAmount());
        assertFalse(actualFallbackFee.getFixedFee().hasDenominatingTokenId());
        assertEquals(
                AccountID.newBuilder().setAccountNum(1009).build(),
                royaltyFeeWrapper.feeCollector());
        final var royaltyFeeWrapper2 = royaltyFees.get(1);
        assertEquals(4, royaltyFeeWrapper2.numerator());
        assertEquals(5, royaltyFeeWrapper2.denominator());
        final var actualFallbackFee2 = royaltyFeeWrapper2.fallbackFixedFee().asGrpc();
        assertEquals(5, actualFallbackFee2.getFixedFee().getAmount());
        assertEquals(
                TokenID.newBuilder().setTokenNum(1).build(),
                actualFallbackFee2.getFixedFee().getDenominatingTokenId());
        assertNull(royaltyFeeWrapper2.feeCollector());
    }

    @Test
    void decodeTokenCreateWithEmptyAddressesAsExpected() {
        final Tuple decodedArguments =
                decodeFunctionCall(
                        CREATE_FUNGIBLE_WITH_FEES_INPUT_NULL_ACCOUNTS,
                        TOKEN_CREATE_FUNGIBLE_WITH_FEES_SELECTOR,
                        TOKEN_CREATE_FUNGIBLE_WITH_FEES_DECODER);
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeFungibleCreateWithFees(
                                        CREATE_FUNGIBLE_WITH_FEES_INPUT_NULL_ACCOUNTS, identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeTokenCreateWithoutFees(
                                        decodedArguments.get(0),
                                        true,
                                        decodedArguments.get(1),
                                        decodedArguments.get(2),
                                        identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(() -> decodeFixedFees(decodedArguments.get(3), identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(() -> decodeFractionalFees(decodedArguments.get(4), identity()))
                .thenCallRealMethod();
        final var decodedInput =
                decodeFungibleCreateWithFees(
                        CREATE_FUNGIBLE_WITH_FEES_INPUT_NULL_ACCOUNTS, identity());

        assertNull(decodedInput.getTreasury());
        assertNull(decodedInput.getTokenKeys().get(0).key().getContractID());
        assertNull(decodedInput.getTokenKeys().get(1).key().getDelegatableContractID());
        assertFalse(decodedInput.getFixedFees().get(0).asGrpc().hasFeeCollectorAccountId());
        assertFalse(decodedInput.getFractionalFees().get(0).asGrpc().hasFeeCollectorAccountId());
    }

    @Test
    void decodesTokenCreateWithRoyaltyFeeWithEmptyAddressesAsExpected() {
        final Tuple decodedArguments =
                decodeFunctionCall(
                        CREATE_NON_FUNGIBLE_WITH_EMPTY_ROYALTY_FEE,
                        TOKEN_CREATE_NON_FUNGIBLE_WITH_FEES_SELECTOR,
                        TOKEN_CREATE_NON_FUNGIBLE_WITH_FEES_DECODER);
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeNonFungibleCreateWithFees(
                                        CREATE_NON_FUNGIBLE_WITH_EMPTY_ROYALTY_FEE, identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeTokenCreateWithoutFees(
                                        decodedArguments.get(0),
                                        false,
                                        BigInteger.ZERO,
                                        BigInteger.ZERO,
                                        identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(() -> decodeFixedFees(decodedArguments.get(1), identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(() -> decodeRoyaltyFees(decodedArguments.get(2), identity()))
                .thenCallRealMethod();
        final var decodedInput =
                decodeNonFungibleCreateWithFees(
                        CREATE_NON_FUNGIBLE_WITH_EMPTY_ROYALTY_FEE, identity());

        final var royaltyFee = decodedInput.getRoyaltyFees().get(0).asGrpc();
        assertFalse(royaltyFee.hasFeeCollectorAccountId());
        assertFalse(royaltyFee.getRoyaltyFee().hasFallbackFee());
    }

    @Test
    void decodeCreateTokenWithInvalidInput() {
        UnaryOperator<byte[]> identity = identity();
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeFungibleCreate(
                                        CREATE_FUNGIBLE_NO_FEES_TOKEN_KEY_EXCEEDING_INTEGER_MAX_INVALID_INPUT,
                                        identity))
                .thenCallRealMethod();
        assertThrows(
                IllegalArgumentException.class,
                () ->
                        decodeFungibleCreate(
                                CREATE_FUNGIBLE_NO_FEES_TOKEN_KEY_EXCEEDING_INTEGER_MAX_INVALID_INPUT,
                                identity));
    }

    @Test
    void decodeFungibleCreateNoFeesInputV2() {
        final Tuple decodedArguments =
                decodeFunctionCall(
                        CREATE_FUNGIBLE_NO_FEES_INPUT_V2,
                        TOKEN_CREATE_FUNGIBLE_SELECTOR_V2,
                        TOKEN_CREATE_FUNGIBLE_DECODER);
        tokenCreatePrecompile
                .when(() -> decodeFungibleCreateV2(CREATE_FUNGIBLE_NO_FEES_INPUT_V2, identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeTokenCreateWithoutFees(
                                        decodedArguments.get(0),
                                        true,
                                        decodedArguments.get(1),
                                        decodedArguments.get(2),
                                        identity()))
                .thenCallRealMethod();
        final var decodedInput =
                decodeFungibleCreateV2(CREATE_FUNGIBLE_NO_FEES_INPUT_V2, identity());

        assertEquals(BigInteger.valueOf(9223372036854775807L), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(4), decodedInput.getDecimals());
        assertExpectedKeys(decodedInput);

        assertExpectedFungibleTokenCreateStructV2(decodedInput);
    }

    @Test
    void decodeFungibleCreateWithFeesInputV2() {
        final Tuple decodedArguments =
                decodeFunctionCall(
                        CREATE_FUNGIBLE_WITH_FEES_INPUT_V2,
                        TOKEN_CREATE_FUNGIBLE_WITH_FEES_SELECTOR_V2,
                        TOKEN_CREATE_FUNGIBLE_WITH_FEES_DECODER);
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeFungibleCreateWithFeesV2(
                                        CREATE_FUNGIBLE_WITH_FEES_INPUT_V2, identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeTokenCreateWithoutFees(
                                        decodedArguments.get(0),
                                        true,
                                        decodedArguments.get(1),
                                        decodedArguments.get(2),
                                        identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(() -> decodeFixedFees(decodedArguments.get(3), identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(() -> decodeFractionalFees(decodedArguments.get(4), identity()))
                .thenCallRealMethod();
        final var decodedInput =
                decodeFungibleCreateWithFeesV2(CREATE_FUNGIBLE_WITH_FEES_INPUT_V2, identity());

        assertExpectedFungibleTokenCreateStructV2(decodedInput);

        assertEquals(decodedInput.getInitSupply(), BigInteger.valueOf(9223372036854775807L));
        assertEquals(decodedInput.getDecimals(), BigInteger.valueOf(4));
        assertExpectedKeys(decodedInput);

        final var fixedFees = decodedInput.getFixedFees();
        assertEquals(1, fixedFees.size());
        final var fixedFeeWrapper = fixedFees.get(0);
        assertEquals(USE_EXISTING_FUNGIBLE_TOKEN, fixedFeeWrapper.getFixedFeePayment());
        final var customFee = fixedFeeWrapper.asGrpc();
        assertEquals(0, customFee.getFixedFee().getAmount());
        assertEquals(
                TokenID.newBuilder().setTokenNum(1).setRealmNum(0).setShardNum(0).build(),
                customFee.getFixedFee().getDenominatingTokenId());
        assertEquals(
                AccountID.newBuilder().setAccountNum(1).build(),
                customFee.getFeeCollectorAccountId());

        final var fractionalFees = decodedInput.getFractionalFees();
        assertEquals(1, fractionalFees.size());
        final var fractionalFeeWrapper = fractionalFees.get(0);
        assertEquals(1, fractionalFeeWrapper.numerator());
        assertEquals(1, fractionalFeeWrapper.denominator());
        assertEquals(1, fractionalFeeWrapper.minimumAmount());
        assertEquals(1, fractionalFeeWrapper.maximumAmount());
        assertFalse(fractionalFeeWrapper.netOfTransfers());
        assertEquals(
                AccountID.newBuilder().setAccountNum(1).build(),
                fractionalFeeWrapper.feeCollector());
    }

    @Test
    void decodeNonFungibleCreateNoFeesInputV2() {
        final Tuple decodedArguments =
                decodeFunctionCall(
                        CREATE_NON_FUNGIBLE_NO_FEES_INPUT_V2,
                        TOKEN_CREATE_NON_FUNGIBLE_SELECTOR_V2,
                        TOKEN_CREATE_NON_FUNGIBLE_DECODER);
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeNonFungibleCreateV2(
                                        CREATE_NON_FUNGIBLE_NO_FEES_INPUT_V2, identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeTokenCreateWithoutFees(
                                        decodedArguments.get(0),
                                        false,
                                        BigInteger.ZERO,
                                        BigInteger.ZERO,
                                        identity()))
                .thenCallRealMethod();
        final var decodedInput =
                decodeNonFungibleCreateV2(CREATE_NON_FUNGIBLE_NO_FEES_INPUT_V2, identity());

        assertFalse(decodedInput.isFungible());
        assertEquals("MyNFTV2", decodedInput.getName());
        assertEquals("NFTV2", decodedInput.getSymbol());
        assertEquals(AccountID.newBuilder().setAccountNum(1L).build(), decodedInput.getTreasury());
        assertEquals("nftMemoV2", decodedInput.getMemo());
        assertTrue(decodedInput.isSupplyTypeFinite());
        assertEquals(9223372036854775807L, decodedInput.getMaxSupply());
        assertFalse(decodedInput.isFreezeDefault());
        assertEquals(0L, decodedInput.getExpiry().second());
        assertEquals(8000000L, decodedInput.getExpiry().autoRenewPeriod());
        assertEquals(
                AccountID.newBuilder().setAccountNum(4L).build(),
                decodedInput.getExpiry().autoRenewAccount());
        assertEquals(BigInteger.valueOf(0), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(0), decodedInput.getDecimals());
        assertExpectedKeys(decodedInput);
    }

    @Test
    void decodeNonFungibleCreateWithFeesInputV2() {
        final Tuple decodedArguments =
                decodeFunctionCall(
                        CREATE_NON_FUNGIBLE_WITH_FEES_INPUT_V2,
                        TOKEN_CREATE_NON_FUNGIBLE_WITH_FEES_SELECTOR_V2,
                        TOKEN_CREATE_NON_FUNGIBLE_WITH_FEES_DECODER);
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeNonFungibleCreateWithFeesV2(
                                        CREATE_NON_FUNGIBLE_WITH_FEES_INPUT_V2, identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(
                        () ->
                                decodeTokenCreateWithoutFees(
                                        decodedArguments.get(0),
                                        false,
                                        BigInteger.ZERO,
                                        BigInteger.ZERO,
                                        identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(() -> decodeFixedFees(decodedArguments.get(1), identity()))
                .thenCallRealMethod();
        tokenCreatePrecompile
                .when(() -> decodeRoyaltyFees(decodedArguments.get(2), identity()))
                .thenCallRealMethod();
        final var decodedInput =
                decodeNonFungibleCreateWithFeesV2(
                        CREATE_NON_FUNGIBLE_WITH_FEES_INPUT_V2, identity());

        assertFalse(decodedInput.isFungible());
        assertEquals("MyNFTV2", decodedInput.getName());
        assertEquals("NFTV2", decodedInput.getSymbol());
        assertEquals(AccountID.newBuilder().setAccountNum(1L).build(), decodedInput.getTreasury());
        assertEquals("nftMemoV2", decodedInput.getMemo());
        assertTrue(decodedInput.isSupplyTypeFinite());
        assertEquals(9223372036854775807L, decodedInput.getMaxSupply());
        assertFalse(decodedInput.isFreezeDefault());
        assertEquals(0L, decodedInput.getExpiry().second());
        assertEquals(8000000L, decodedInput.getExpiry().autoRenewPeriod());
        assertEquals(
                AccountID.newBuilder().setAccountNum(4L).build(),
                decodedInput.getExpiry().autoRenewAccount());
        assertEquals(BigInteger.valueOf(0), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(0), decodedInput.getDecimals());
        assertExpectedKeys(decodedInput);

        final var fixedFees = decodedInput.getFixedFees();
        assertEquals(1, fixedFees.size());
        final var fixedFeeWrapper = fixedFees.get(0);
        assertEquals(USE_EXISTING_FUNGIBLE_TOKEN, fixedFeeWrapper.getFixedFeePayment());
        final var customFee = fixedFeeWrapper.asGrpc();
        assertEquals(0, customFee.getFixedFee().getAmount());
        assertEquals(
                TokenID.newBuilder().setTokenNum(1).build(),
                customFee.getFixedFee().getDenominatingTokenId());
        assertEquals(
                AccountID.newBuilder().setAccountNum(1).build(),
                customFee.getFeeCollectorAccountId());

        final var royaltyFees = decodedInput.getRoyaltyFees();
        assertEquals(1, royaltyFees.size());
        final var royaltyFeeWrapper = royaltyFees.get(0);
        assertEquals(1, royaltyFeeWrapper.numerator());
        assertEquals(2, royaltyFeeWrapper.denominator());
        final var actualFallbackFee = royaltyFeeWrapper.fallbackFixedFee().asGrpc();
        assertEquals(3, actualFallbackFee.getFixedFee().getAmount());
        assertTrue(actualFallbackFee.getFixedFee().hasDenominatingTokenId());
        assertEquals(
                AccountID.newBuilder().setAccountNum(2).build(), royaltyFeeWrapper.feeCollector());
    }

    private void assertExpectedFungibleTokenCreateStructV2(final TokenCreateWrapper decodedInput) {
        assertTrue(decodedInput.isFungible());
        assertEquals("MyTokenV2", decodedInput.getName());
        assertEquals("MTKV2", decodedInput.getSymbol());
        assertEquals(AccountID.newBuilder().setAccountNum(1L).build(), decodedInput.getTreasury());
        assertEquals("memoV2", decodedInput.getMemo());
        assertFalse(decodedInput.isSupplyTypeFinite());
        assertEquals(9223372036854775807L, decodedInput.getMaxSupply());
        assertFalse(decodedInput.isFreezeDefault());
        assertEquals(8000000, decodedInput.getExpiry().autoRenewPeriod());
        assertEquals(
                AccountID.newBuilder().setAccountNum(4L).build(),
                decodedInput.getExpiry().autoRenewAccount());
        assertEquals(0L, decodedInput.getExpiry().second());
    }

    private void assertExpectedFungibleTokenCreateStruct(final TokenCreateWrapper decodedInput) {
        assertTrue(decodedInput.isFungible());
        assertEquals("MyToken", decodedInput.getName());
        assertEquals("MTK", decodedInput.getSymbol());
        assertEquals(AccountID.newBuilder().setAccountNum(1L).build(), decodedInput.getTreasury());
        assertEquals("memo", decodedInput.getMemo());
        assertFalse(decodedInput.isSupplyTypeFinite());
        assertEquals(0L, decodedInput.getMaxSupply());
        assertFalse(decodedInput.isFreezeDefault());
        assertEquals(5554, decodedInput.getExpiry().autoRenewPeriod());
        assertEquals(
                AccountID.newBuilder().setAccountNum(2L).build(),
                decodedInput.getExpiry().autoRenewAccount());
        assertEquals(0L, decodedInput.getExpiry().second());
    }

    private void assertExpectedNonFungibleTokenCreateStruct(final TokenCreateWrapper decodedInput) {
        assertFalse(decodedInput.isFungible());
        assertEquals("MyNFT", decodedInput.getName());
        assertEquals("NFT", decodedInput.getSymbol());
        assertEquals(AccountID.newBuilder().setAccountNum(1L).build(), decodedInput.getTreasury());
        assertEquals("nftMemo", decodedInput.getMemo());
        assertTrue(decodedInput.isSupplyTypeFinite());
        assertEquals(55L, decodedInput.getMaxSupply());
        assertTrue(decodedInput.isFreezeDefault());
        assertEquals(67574665L, decodedInput.getExpiry().second());
        assertEquals(0L, decodedInput.getExpiry().autoRenewPeriod());
        assertNull(decodedInput.getExpiry().autoRenewAccount());
    }

    private void assertExpectedKeys(TokenCreateWrapper decodedInput) {
        final var tokenKeys = decodedInput.getTokenKeys();
        assertEquals(2, tokenKeys.size());

        final var key1 = tokenKeys.get(0);
        assertEquals(
                KeyValueWrapper.KeyValueType.INHERIT_ACCOUNT_KEY, key1.key().getKeyValueType());
        assertTrue(key1.isUsedForAdminKey());
        assertEquals(1, key1.keyType());

        final var key2 = tokenKeys.get(1);
        assertEquals(KeyValueWrapper.KeyValueType.CONTRACT_ID, key2.key().getKeyValueType());
        assertEquals(ContractID.newBuilder().setContractNum(1).build(), key2.key().getContractID());
        assertTrue(key2.isUsedForSupplyKey());
        assertTrue(key2.isUsedForPauseKey());
        assertEquals(80, key2.keyType());
    }

    private void prepareAndAssertCreateHappyPathSucceeds(
            TokenCreateWrapper tokenCreateWrapper, Bytes pretendArguments) {
        givenMinimalFrameContext();
        givenLedgers();
        givenValidGasCalculation();
        given(aliases.resolveForEvm(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(worldUpdater.aliases()).willReturn(aliases);
        given(mockSynthBodyBuilder.build())
                .willReturn(
                        TransactionBody.newBuilder()
                                .setTokenCreation(tokenCreateTransactionBody)
                                .build());
        given(mockSynthBodyBuilder.setTransactionID(any(TransactionID.class)))
                .willReturn(mockSynthBodyBuilder);
        given(syntheticTxnFactory.createTokenCreate(tokenCreateWrapper))
                .willReturn(mockSynthBodyBuilder);
        given(frame.getSenderAddress()).willReturn(senderAddress);
        given(mockSynthBodyBuilder.getTokenCreation()).willReturn(tokenCreateTransactionBody);
        given(sigsVerifier.hasActiveKey(Mockito.anyBoolean(), any(), any(), any()))
                .willReturn(true);
        final var tokenCreateValidator = Mockito.mock(Function.class);
        given(createChecks.validatorForConsTime(any())).willReturn(tokenCreateValidator);
        given(tokenCreateValidator.apply(any())).willReturn(ResponseCodeEnum.OK);
        given(infrastructureFactory.newAccountStore(accounts)).willReturn(accountStore);
        given(
                        infrastructureFactory.newTokenStore(
                                accountStore, sideEffects, tokens, nfts, tokenRels))
                .willReturn(typedTokenStore);
        given(infrastructureFactory.newTokenCreateLogic(accountStore, typedTokenStore))
                .willReturn(createLogic);
        given(infrastructureFactory.newCreateChecks()).willReturn(createChecks);
        given(recordsHistorian.nextFollowingChildConsensusTime()).willReturn(pendingChildConsTime);
        given(
                        creator.createSuccessfulSyntheticRecord(
                                Collections.emptyList(), sideEffects, EMPTY_MEMO))
                .willReturn(mockRecordBuilder);
        given(mockRecordBuilder.getReceiptBuilder())
                .willReturn(
                        TxnReceipt.newBuilder()
                                .setTokenId(
                                        EntityId.fromGrpcTokenId(
                                                TokenID.newBuilder().setTokenNum(1L).build())));
        given(encoder.encodeCreateSuccess(any())).willReturn(successResult);

        // when:
        final var result = subject.computePrecompile(pretendArguments, frame);

        // then:
        assertEquals(successResult, result.getOutput());
        // and:
        verify(createLogic)
                .create(
                        pendingChildConsTime.getEpochSecond(),
                        EntityIdUtils.accountIdFromEvmAddress(senderAddress),
                        tokenCreateTransactionBody);
        verify(wrappedLedgers).commit();
        verify(worldUpdater)
                .manageInProgressRecord(recordsHistorian, mockRecordBuilder, mockSynthBodyBuilder);
    }

    private void prepareAndAssertRevertReasonIsSetAndNullIsReturned(
            TokenCreateWrapper tokenCreateWrapper) {
        given(dynamicProperties.isHTSPrecompileCreateEnabled()).willReturn(true);
        given(frame.getWorldUpdater()).willReturn(worldUpdater);
        given(worldUpdater.wrappedTrackingLedgers(any())).willReturn(wrappedLedgers);
        Bytes pretendArguments = Bytes.of(Integers.toBytes(ABI_ID_CREATE_NON_FUNGIBLE_TOKEN));
        tokenCreatePrecompile
                .when(() -> decodeNonFungibleCreate(eq(pretendArguments), any()))
                .thenReturn(tokenCreateWrapper);
        given(frame.getSenderAddress()).willReturn(senderAddress);

        // when:
        final var result = subject.computePrecompile(pretendArguments, frame);

        // then:
        assertNull(result.getOutput());

        // and
        verify(frame).setRevertReason(any());
        verifyNoInteractions(createLogic);
        verify(wrappedLedgers, never()).commit();
        verify(worldUpdater, never())
                .manageInProgressRecord(recordsHistorian, mockRecordBuilder, mockSynthBodyBuilder);
    }

    private void givenMinimalFrameContext() {
        given(dynamicProperties.isHTSPrecompileCreateEnabled()).willReturn(true);
        given(frame.getContractAddress()).willReturn(contractAddr);
        given(frame.getWorldUpdater()).willReturn(worldUpdater);
        given(frame.getRemainingGas()).willReturn(100_000L);
        Optional<WorldUpdater> parent = Optional.of(worldUpdater);
        given(worldUpdater.parentUpdater()).willReturn(parent);
        given(worldUpdater.wrappedTrackingLedgers(any())).willReturn(wrappedLedgers);
    }

    private void givenLedgers() {
        given(wrappedLedgers.accounts()).willReturn(accounts);
        given(wrappedLedgers.tokenRels()).willReturn(tokenRels);
        given(wrappedLedgers.nfts()).willReturn(nfts);
        given(wrappedLedgers.tokens()).willReturn(tokens);
    }

    private void givenValidGasCalculation() {
        given(feeCalculator.computeFee(any(), any(), any(), any()))
                .willReturn(new FeeObject(TEST_NODE_FEE, TEST_NETWORK_FEE, TEST_SERVICE_FEE));
        given(feeCalculator.estimatedGasPriceInTinybars(any(), any())).willReturn(1L);
        given(frame.getValue()).willReturn(Wei.of(1_000_000L));

        final var blockValuesMock = mock(BlockValues.class);
        given(frame.getBlockValues()).willReturn(blockValuesMock);
        given(blockValuesMock.getTimestamp()).willReturn(timestamp.getSeconds());

        final var mockSenderEvmAccount = Mockito.mock(EvmAccount.class);
        given(worldUpdater.getAccount(senderAddress)).willReturn(mockSenderEvmAccount);
        senderMutableAccount = new UpdateTrackingLedgerAccount(senderAddress, null);
        given(mockSenderEvmAccount.getMutable()).willReturn(senderMutableAccount);
        senderMutableAccount.setBalance(Wei.of(SENDER_INITIAL_BALANCE));

        given(dynamicProperties.fundingAccount()).willReturn(account);
        final var mockFundingEvmAccount = mock(EvmAccount.class);
        given(
                        worldUpdater.getAccount(
                                Id.fromGrpcAccount(dynamicProperties.fundingAccount())
                                        .asEvmAddress()))
                .willReturn(mockFundingEvmAccount);
        fundingMutableAccount =
                new UpdateTrackingLedgerAccount(EntityIdUtils.asTypedEvmAddress(account), null);
        given(mockFundingEvmAccount.getMutable()).willReturn(fundingMutableAccount);
        fundingMutableAccount.setBalance(Wei.of(FUNDING_ACCOUNT_INITIAL_BALANCE));
    }
}
