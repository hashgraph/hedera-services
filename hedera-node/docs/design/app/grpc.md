# gRPC

gRPC is a simple protocol built on top of HTTP/2. The typical way of working with gRPC is to use the `protoc` compiler
to generate stubs for each method in a gRPC service. The stubs take pre-parsed protobuf objects and return protobuf
objects and all serialization is handled by the framework. This doesn't work all that well for us.

When we receive a gRPC request for paid queries or for any transaction, we need the raw bytes to send to the hashgraph
platform for consensus. We would like to get the raw bytes from the gRPC request, not pre-parsed objects. We also have
our own highly tuned protobuf parsing library that generates nearly no garbage, and we would like to use it for parsing
rather than the code generated by `protoc`. For these reasons, the built-in gRPC frameworks are of little to use to us.

It turns out that gRPC is an extremely simple API built on top of HTTP/2, and we can therefore have our own simple gRPC
framework built on top of an HTTP/2 server (like Netty) and get everything we want.

## Architecture Overview

The gRPC package in Hedera App defines `GrpcServerManager` interface with a number of lifecycle methods such as
`start()`, `stop()` and `isRunning()`, and an implementation of this interface based on Netty. Hedera App runs at least
one gRPC server on the port specified in the config, and optionally it will also attempt to run a gRPC servers on the
TLS or node operator ports specified in the same config.


### NettyGrpcServerManager

`NettyGrpcServerManager` is an implementation of `GrpcServerManager` and it uses the Hedera App's services registry in
order to gather the set of RPC endpoints and their corresponding handlers. Given that set and using the
`GrpcServiceBuilder` class we produce gRPC `ServerServiceDefinition`s which can be directly registered with the Netty
server.

### GrpcServiceBuilder

As stated above `GrpcServiceBuilder` produces gRPC `ServerServiceDefinition`s, those definitions are wired in with the
proper Services handlers and gRPC `ServerCall.Listener` methods. During runtime the Netty server will be calling those
listener methods e.g. `onMessage()` is where we integrate Service logic for handling transactions or queries by using 
the abstract `MethodBase` type.

### MethodBase

In this abstract class we check the size of the request and we fail if it's too large. Additionally, we track metrics
for number of calls and calls per second that were receive, failed or successfully handled. There are two concrete types
(`QueryMethod` and `TransactionMethod`) that extend `MethodBase` and implement the `handle()` method, which when called
will invoke the `QueryWorkflow` or `IngestWorkflow` respectively.

**NEXT: [Records](records.md)**
