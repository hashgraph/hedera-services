// SPDX-License-Identifier: Apache-2.0
package com.hedera.node.app.spi.fixtures.util;

import static java.util.Objects.requireNonNull;

import edu.umd.cs.findbugs.annotations.NonNull;
import java.lang.reflect.Field;
import java.util.stream.Stream;
import org.apache.logging.log4j.LogManager;
import org.junit.jupiter.api.extension.AfterEachCallback;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.TestInstancePostProcessor;

/**
 * JUnit5 extension that captures the logging events generated by an annotated {@link
 * LoggingSubject} per executed {@code @Test} method. The events are accessible by methods on a
 * {@link LogCaptor} instance which must be a field on the test instance.
 *
 * <p>For example, suppose {@code ExampleService} is a class whose log events are generated on a
 * {@code Logger} acquired by {@code LogManager.getLogger(ExampleService.class)}. Then we can test
 * its logs as below.
 *
 * <pre>{@code
 * {@literal @}ExtendWith(LogCaptureExtension.class)
 *  class ExampleServiceTest {
 *     {@literal @}Inject
 *     private LogCaptor logCaptor;
 *
 *     {@literal @}LoggingSubject
 *     private ExampleService subject;
 *
 *     {@literal @}Test
 *     void logsWhatIsExpected() {
 *         // when:
 *         subject.doVerbosely();
 *
 *         // then:
 *         assertEquals("2 + 2 = 4", logCaptor.debugLogs().get(0));
 *         assertEquals(
 *           List.of("Beware the Jabberwock, my son!", "The jaws that bite, the claws that catch!"),
 *           logCaptor.warnLogs());
 *     }
 *  }
 * }</pre>
 *
 * This class was copied over from mono-service. When mono-service module goes away, it will be deleted from there
 * and this will be the only copy.
 */
public class LogCaptureExtension implements TestInstancePostProcessor, AfterEachCallback {
    private LogCaptor injectedCaptor = null;

    @Override
    public void afterEach(ExtensionContext extensionContext) {
        if (injectedCaptor != null) {
            injectedCaptor.stopCapture();
        }
    }

    @Override
    public void postProcessTestInstance(@NonNull final Object o, @NonNull final ExtensionContext extensionContext)
            throws IllegalAccessException {
        requireNonNull(o);
        requireNonNull(extensionContext);

        final Class<?> testCls = o.getClass();

        Field subject = null;
        Field logCaptor = null;

        for (var field : testCls.getDeclaredFields()) {
            if (subject == null && isSubject(field)) {
                subject = field;
            } else {
                if (isInjectableCaptor(field)) {
                    logCaptor = field;
                }
            }
        }

        if (subject == null) {
            throw new IllegalStateException("The test class has no designated subject");
        }
        if (logCaptor == null) {
            throw new IllegalStateException("The test class has no LogCaptor field marked with @LoggingTarget");
        }

        injectCaptor(o, subject, logCaptor);
    }

    // Suppress the warning that the reflection shouldn't be used
    @SuppressWarnings("java:S3011")
    private void injectCaptor(@NonNull final Object test, @NonNull final Field subject, @NonNull final Field logCaptor)
            throws IllegalAccessException {
        requireNonNull(test);
        requireNonNull(subject);
        requireNonNull(logCaptor);
        logCaptor.setAccessible(true);
        injectedCaptor = new LogCaptor(LogManager.getLogger(subject.getType()));
        logCaptor.set(test, injectedCaptor);
    }

    private static boolean isSubject(@NonNull final Field field) {
        requireNonNull(field);
        final var annotations = field.getDeclaredAnnotations();
        return Stream.of(annotations).anyMatch(a -> a.annotationType().equals(LoggingSubject.class));
    }

    private static boolean isInjectableCaptor(@NonNull final Field field) {
        if (!field.getType().equals(LogCaptor.class)) {
            return false;
        }
        final var annotations = field.getDeclaredAnnotations();
        return Stream.of(annotations).anyMatch(a -> a.annotationType().equals(LoggingTarget.class));
    }
}
