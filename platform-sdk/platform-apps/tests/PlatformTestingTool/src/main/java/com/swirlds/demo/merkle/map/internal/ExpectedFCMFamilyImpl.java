// SPDX-License-Identifier: Apache-2.0
package com.swirlds.demo.merkle.map.internal;

import static com.swirlds.common.utility.CommonUtils.hex;
import static com.swirlds.logging.legacy.LogMarker.EXCEPTION;
import static com.swirlds.merkle.test.fixtures.map.lifecycle.EntityType.Crypto;
import static com.swirlds.merkle.test.fixtures.map.lifecycle.EntityType.FCQ;
import static com.swirlds.merkle.test.fixtures.map.lifecycle.EntityType.NFT;
import static com.swirlds.merkle.test.fixtures.map.lifecycle.EntityType.VIRTUAL_MERKLE_ACCOUNT;
import static com.swirlds.merkle.test.fixtures.map.lifecycle.TransactionState.INITIALIZED;
import static com.swirlds.merkle.test.fixtures.map.lifecycle.TransactionType.Create;
import static com.swirlds.merkle.test.fixtures.map.lifecycle.TransactionType.Delete;
import static com.swirlds.merkle.test.fixtures.map.lifecycle.TransactionType.Expire;
import static com.swirlds.merkle.test.fixtures.map.lifecycle.TransactionType.Rebuild;

import com.google.protobuf.InvalidProtocolBufferException;
import com.swirlds.common.crypto.Hash;
import com.swirlds.common.merkle.MerkleNode;
import com.swirlds.common.test.fixtures.set.RandomAccessHashSet;
import com.swirlds.demo.merkle.map.FCMConfig;
import com.swirlds.demo.merkle.map.FCMFamily;
import com.swirlds.demo.merkle.map.FCMTransactionUtils;
import com.swirlds.demo.platform.PAYLOAD_TYPE;
import com.swirlds.demo.platform.PayloadCfgSimple;
import com.swirlds.demo.platform.PayloadConfig;
import com.swirlds.demo.platform.fs.stresstest.proto.TestTransaction;
import com.swirlds.demo.platform.fs.stresstest.proto.TestTransactionWrapper;
import com.swirlds.demo.platform.nft.NftId;
import com.swirlds.merkle.test.fixtures.map.lifecycle.EntityType;
import com.swirlds.merkle.test.fixtures.map.lifecycle.ExpectedValue;
import com.swirlds.merkle.test.fixtures.map.lifecycle.LifecycleStatus;
import com.swirlds.merkle.test.fixtures.map.lifecycle.TransactionState;
import com.swirlds.merkle.test.fixtures.map.lifecycle.TransactionType;
import com.swirlds.merkle.test.fixtures.map.pta.MapKey;
import com.swirlds.merkle.test.fixtures.map.pta.MapValue;
import java.io.IOException;
import java.security.SecureRandom;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.Marker;
import org.apache.logging.log4j.MarkerManager;

/**
 * Implementation of {#link ExpectedFCMFamily} that keeps track of keys available in either of the FCMs from
 * {#link com.swirlds.demo.platform.fcm.FCMFamily}.
 *
 * This implementation is more suitable when we want to validate more real scenarios, in which we query/mutate
 * values from keys that were not only generated by the current nodes, but from any other node.
 * Given that a transaction might affect a deleted node, multiple validations are checked before proceeding to
 * handle the transaction.
 *
 * This object is used when creating transactions to select which keys are available for update, transfer, or
 * deletion. For this reason, we keep synchronized lists to determine what's available and what not to avoid
 * generating transactions with invalid/deleted keys that would skew our statistics.
 *
 * This object adds overhead given that it has to wait for keys to become available before selecting keys. This
 * waiting period might skew the transaction per second stats.
 *
 * Given the multiple checks and locking overhead, this object might add up to 12 microseconds to the
 * secTransH statistic.
 */
public final class ExpectedFCMFamilyImpl implements ExpectedFCMFamily {

    private static final Marker MARKER = MarkerManager.getMarker("DEMO_INFO");

    private static final Marker ERROR = MarkerManager.getMarker("EXCEPTION");
    private static final Marker EXPIRATION_MARKER = MarkerManager.getMarker("EXPIRATION");
    /**
     * This marker is used to allow CreateOnExistingEntities and PerformOnDeleted errors, which are acceptable only for
     * in killNodeReconnect, as when node is killed delete/create transactions can be submitted for deleted/already
     * existing entities if the previous transaction was not handled before node is killed
     */
    private static final Marker PERFORM_ON_CREATE_DELETE = MarkerManager.getMarker("PERFORM_ON_CREATE_DELETE");

    private static final Marker DEMO_TRANSACTION_INFO = MarkerManager.getMarker("DEMO_TRANSACTION_INFO");
    private static final Marker DEMO_INFO = MarkerManager.getMarker("DEMO_INFO");

    private static final Logger logger = LogManager.getLogger(ExpectedFCMFamily.class);

    /**
     * Map that contains all entities expected to be in MerkleMap
     */
    private Map<MapKey, ExpectedValue> expectedMap;
    /**
     * The largest accountId of all entities present in expectedMap
     */
    private AtomicLong largestInExpectedMap;

    /**
     * /**
     * List of MapKeys that denotes keys of accounts and FCQ entities present in expectedMap.
     * Add MapKeys to respective lists based on entityType, when adding entities to expectedMap
     * during handle of create transactions or restart and reconnect.
     */
    private List<MapKey> accountList;

    private List<MapKey> fcqList;
    private List<MapKey> virtualMerkleAccountList;

    /**
     * Index of each SelfEntitiesList for generating Delete transactions;
     * Entities with index in range [0, deleteIndex) in the SelfEntitiesList
     * should have been removed from actual MerkleMap
     */
    private int cryptoDeleteIdx;

    private int fcqDeleteIdx = 0;
    private int virtualMerkleAccountDeleteIdx;

    /**
     * count of entities with each type in actual MerkleMaps;
     * after handling create transactions successfully, corresponding entityCounter increases by 1
     * after handling delete transactions successfully, corresponding entityCounter decreases by 1
     * the 3 counters will be updated when reconnecting, starting from saved state, or loading ExpectedFCMFamily from
     * file,
     */
    private int cryptoCounter;

    private int fcqCounter = 0;
    private int virtualMerkleAccountCounter;

    /**
     * List of entities created by the current node. Add MapKeys with OriginNode as the current nodeId
     * to this list when rebuilding expectedMap during restart or reconnect. This lists are used to delete
     * entities in sequential order for delete transactions.
     */
    private List<MapKey> accountSelfEntitiesList;

    private List<MapKey> fcqSelfEntitiesList;
    private List<MapKey> virtualMerkleAccountSelfEntitiesList;

    /**
     * current node's Id
     */
    private long nodeId;

    /**
     * FCMConfig which defines the amount of each transaction type;
     * is used for getting expected amount of each EntityType to be created
     */
    private FCMConfig fcmConfig;

    /**
     * number of nodes with non-zero weight in current AddressBook
     * is used for calculating expected amount of each EntityType to be created by all weighted nodes
     * because nodes with zero weight don't submit transactions
     */
    private int weightedNodeNum;

    /**
     * if fcmConfig is null, use this value as default initialCapacity
     */
    private static final int DEFAULT_LIST_CAPACITY = 1000;

    /**
     * number of entity types
     */
    private static final int ENTITY_TYPES_NUM = 4;

    private static final Random RANDOM = new SecureRandom();

    /**
     * Tracks all NFTs that are currently in the state. This does not belong in this class,
     * but the structure of PTT forces all data used for forming transactions to inhabit
     * this class.
     */
    private final transient RandomAccessHashSet<NftId> availableNfts;

    public ExpectedFCMFamilyImpl() {
        largestInExpectedMap = new AtomicLong(0);

        this.availableNfts = new RandomAccessHashSet<>();
        initExpectedMapAndLists(false);
    }

    /**
     * {@inheritDoc}
     */
    public void setNodeId(final long nodeId) {
        this.nodeId = nodeId;
    }

    /**
     * {@inheritDoc}
     */
    public void setFcmConfig(final FCMConfig fcmConfig) {
        this.fcmConfig = fcmConfig;
    }

    /**
     * {@inheritDoc}
     */
    public void setWeightedNodeNum(final int weightedNodeNum) {
        this.weightedNodeNum = weightedNodeNum;
    }

    /**
     * initialize ExpectedMap and EntityLists, and set initial capacity for reducing resizing cost
     *
     * @param isRestart
     * 		if we are to rebuild ExpectedMap and EntityLists after restart,
     * 		we need to add actual entity numbers when calculating initial capacity
     */
    private void initExpectedMapAndLists(final boolean isRestart) {
        if (isRestart) {
            logger.info(DEMO_INFO, "Initialize ExpectedMap and Lists before rebuilding at Restart");
        }
        initExpectedMap(isRestart);
        initEntityListCapacity(Crypto, isRestart);
        initEntityListCapacity(FCQ, isRestart);
        initEntityListCapacity(VIRTUAL_MERKLE_ACCOUNT, isRestart);
    }

    /**
     * if fcmConfig is not null, return expected amount of create transactions for certain EntityType to be handled by
     * each node,
     * i.e., expected amount of create transactions for given EntityType to be submitted by all weighted node;
     * else return default list capacity
     */
    private int getEntityListInitCapacity(final EntityType entityType) {
        return fcmConfig == null
                ? DEFAULT_LIST_CAPACITY
                : fcmConfig.getExpectedEntityAmountForTypePerNode(entityType) * weightedNodeNum;
    }

    /**
     * if fcmConfig is not null, calculate expected amount of create transactions to be handled by each node,
     * i.e., expected amount of create transactions to be submitted by all weighted node;
     * else return default list capacity * number of entity type
     */
    private int getExpectedMapInitCapacity() {
        return fcmConfig == null
                ? DEFAULT_LIST_CAPACITY * ENTITY_TYPES_NUM
                : fcmConfig.getExpectedEntityAmountTotalPerNode() * weightedNodeNum;
    }

    private int getVirtualMerkleAccountCounter() {
        return virtualMerkleAccountCounter;
    }

    private int getCryptoCounter() {
        return cryptoCounter;
    }

    private int getFcqCounter() {
        return fcqCounter;
    }

    public void setCryptoCounter(int cryptoCounter) {
        this.cryptoCounter = cryptoCounter;
    }

    public void setFcqCounter(int fcqCounter) {
        this.fcqCounter = fcqCounter;
    }

    /**
     * get corresponding accountCounter for certain entity
     *
     * @param type
     * 		Entity Type
     * @return Count of FCM type
     */
    private int getCounter(EntityType type) {
        switch (type) {
            case FCQ:
                return this.getFcqCounter();
            case Crypto:
                return this.getCryptoCounter();
            case VIRTUAL_MERKLE_ACCOUNT:
                return this.getVirtualMerkleAccountCounter();
            default:
                throw new IllegalArgumentException("Unrecognized entity type:" + type);
        }
    }

    /**
     * If expectedMap in expectedFCMFamily doesn't have any entities of that entityType,
     * wait for sometime to be come available
     *
     * @param entityType
     * 		Entity Type
     * @return Whether the specified Expected Map is empty or not
     */
    private boolean waitIfExpectedMapEmpty(final EntityType entityType) {
        return this.getCounter(entityType) == 0
                && (this.getExpectedMap() != null && this.getExpectedMap().size() == 0);
    }

    public void waitWhileExpectedMapEmpty(final EntityType entityType, final PAYLOAD_TYPE type) {
        while (this.waitIfExpectedMapEmpty(entityType)) {
            try {
                Thread.sleep(500);
                logger.info(
                        MARKER,
                        "{} is zero, cannot generate transaction of type {}, waiting...",
                        entityType,
                        type.name());
            } catch (InterruptedException e) {
                logger.error(EXCEPTION.getMarker(), "", e);
            }
        }
    }

    public Map<MapKey, ExpectedValue> getExpectedMap() {
        return expectedMap;
    }

    /**
     * return the maximum among total number of entities in expectedMap or
     * largest account Id in ExpectedMap , to be used to create next accountID
     *
     * @return accountId to be created next
     */
    public long getNextIdToCreate() {
        return Math.max(expectedMap.size(), largestInExpectedMap.get() + 1);
    }

    /**
     * return a MapKey for operating in Update/Transfer/Delete/Append FCMTransaction;
     *
     * @param txType
     * 		type of the transaction
     * @param entityType
     * 		type of the entity
     * @param performOnDeleted
     * 		if it is true, return a MapKey in corresponding list
     * 		(which might have been removed from actual MerkleMap);
     * 		if it is false, return a MapKey in corresponding list which
     * 		haven't been removed from actual MerkleMap yet
     * @param operateEntitiesOfSameNode
     * 		if it is true, return a MapKey in corresponding selfEntitiesList
     * @param restrictedCount
     * 		if non-zero, this will only select a subset of this many items out of the appropriate entity list
     * 		convering the range.  So if there were 9 entities in the list and this was 2, you'd get either 0 or 8
     * 		randomly. 3 would select from 0, 4, and 8, etc.
     * @return MapKey if found
     */
    public MapKey getMapKeyForFCMTx(
            final TransactionType txType,
            final EntityType entityType,
            final boolean performOnDeleted,
            final boolean operateEntitiesOfSameNode,
            final int restrictedCount) {
        final List<MapKey> entityList;
        final List<MapKey> selfEntitiesList;
        final int deleteIdx;
        switch (entityType) {
            case Crypto:
                entityList = accountList;
                selfEntitiesList = accountSelfEntitiesList;
                deleteIdx = cryptoDeleteIdx;
                break;
            case FCQ:
                entityList = fcqList;
                selfEntitiesList = fcqSelfEntitiesList;
                deleteIdx = fcqDeleteIdx;
                break;
            case VIRTUAL_MERKLE_ACCOUNT:
                entityList = virtualMerkleAccountList;
                selfEntitiesList = virtualMerkleAccountSelfEntitiesList;
                deleteIdx = virtualMerkleAccountDeleteIdx;
                break;
            default:
                throw new IllegalArgumentException("Unknown EntityType: " + entityType);
        }

        MapKey mapKey;

        // for Delete transactions, we start from deleteIdx and find the first un-removed entity
        if (txType.equals(Delete)) {
            mapKey = getMapKeyToDelete(deleteIdx, selfEntitiesList, entityType);
        } else {
            /*
            for Update/Transfer/Append transactions,
            If the test is allowed to perform on deleted entity
            return a random MapKey of the entity type
            */
            if (performOnDeleted) {
                mapKey = getRandomMapKey(
                        deleteIdx, entityList, selfEntitiesList, operateEntitiesOfSameNode, restrictedCount);
            } else {
                // If performOnDeleted is false, we should always generate valid MapKey
                do {
                    mapKey = getRandomMapKey(
                            deleteIdx, entityList, selfEntitiesList, operateEntitiesOfSameNode, restrictedCount);
                } while (isRemovedEntity(mapKey));
            }
        }
        if (mapKey == null) {
            if (restrictedCount > 0) {
                logger.info(
                        DEMO_TRANSACTION_INFO,
                        String.format(
                                "getMapKeyForFCMTx :: Fail to choose MapKey when"
                                        + " initializing %s %s account subset Transaction, because %sList in ExpectedMap is "
                                        + "empty"
                                        + " or all entities "
                                        + "has been removed. deleteIdx: %s, entityList size: %s, selfEntitiesList size: %s, "
                                        + "accountSubset: %s",
                                txType,
                                entityType,
                                entityType,
                                deleteIdx,
                                entityList.size(),
                                selfEntitiesList.size(),
                                restrictedCount));
            } else {
                logger.info(
                        DEMO_TRANSACTION_INFO,
                        String.format(
                                "getMapKeyForFCMTx :: Fail to choose MapKey when"
                                        + " initializing %s %s Transaction, because %sList in ExpectedMap is empty or all "
                                        + "entities "
                                        + "has been removed. deleteIdx: %s, entityList size: %s, selfEntitiesList size: %s",
                                txType, entityType, entityType, deleteIdx, entityList.size(), selfEntitiesList.size()));
            }
        }

        return mapKey;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public synchronized Optional<NftId> getAnyNftId() {
        if (availableNfts.isEmpty()) {
            return Optional.empty();
        }
        return Optional.of(availableNfts.get(RANDOM));
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean doesTokenWithIdExist(final NftId id) {
        return availableNfts.contains(id);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public synchronized void addNftId(final NftId nftId) {
        this.availableNfts.add(nftId);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public synchronized boolean removeNftid(final NftId nftId) {
        return availableNfts.remove(nftId);
    }

    /**
     * Generate a random number 0..range-1, with the caveat that only restrictedCount of those
     * values will ever occur.
     *
     * @param range
     * @param restrictedCount
     * 		if non-zero, this will only select a subset of this many integers covering 0..range-1.
     * 		So if the range was 15 and the restricted count was 3, you would only get 0, 7, and 14
     * 		-- randomly, of course.
     * 		Additionally, if the restrictedCount is _larger_ than the range, it will provide a uniform
     * 		distribution across the range.
     * @return Next random int
     */
    private int nextStructuredRandomInt(final int range, final int restrictedCount) {
        if ((restrictedCount < 2) || (range <= restrictedCount)) {
            return ThreadLocalRandom.current().nextInt(range);
        } else {
            final double scalar = ((float) range - 1.0) / ((float) restrictedCount - 1.0);
            return (int) Math.floor(ThreadLocalRandom.current().nextInt(restrictedCount) * scalar);
        }
    }

    /**
     * get a random MapKey from an entityList for Update/Transfer/Append transactions
     *
     * @param deleteIdx
     * 		entities with index in range [0, deleteIndex) in the SelfEntitiesList
     * 		should have been removed from actual MerkleMap
     * @param entityList
     * 		corresponding entityList
     * @param selfEntitiesList
     * 		corresponding SelfEntitiesList
     * @param restrictedCount
     * 		if non-zero, this will only select a subset of this many items out of the appropriate entity list
     * 		convering the range.  So if there were 9 entities in the list and this was 2, you'd get either 0 or 8
     * 		randomly. 3 would select from 0, 4, and 8, etc.
     * @return Random MapKey
     */
    private MapKey getRandomMapKey(
            final int deleteIdx,
            final List<MapKey> entityList,
            final List<MapKey> selfEntitiesList,
            final boolean operateEntitiesOfSameNode,
            final int restrictedCount) {
        if (operateEntitiesOfSameNode) {
            if (selfEntitiesList.isEmpty() || deleteIdx >= selfEntitiesList.size()) {
                return null;
            }
            return selfEntitiesList.get(nextStructuredRandomInt(selfEntitiesList.size(), restrictedCount));
        } else {
            if (entityList.isEmpty() || deleteIdx >= selfEntitiesList.size()) {
                return null;
            }
            return entityList.get(nextStructuredRandomInt(entityList.size(), restrictedCount));
        }
    }

    /**
     * get a MapKey for Delete transactions
     *
     * @param deleteIdx
     * 		entities with index in range [0, deleteIndex) in the entityList
     * 		should have been removed from actual MerkleMap
     * @param entityList
     * 		a list which contains certain type of entities created by current node
     * @param entityType
     * 		type of entity to be deleted
     * @return MapKey to delete
     */
    private MapKey getMapKeyToDelete(final int deleteIdx, final List<MapKey> entityList, final EntityType entityType) {
        MapKey key = null;

        for (int i = deleteIdx; i < entityList.size(); i++) {
            key = entityList.get(i);
            if (!isRemovedEntity(key)) {
                // update deleteIdx to be i + 1
                updateDeleteIndex(entityType, i + 1);
                return key;
            }
        }

        // entityList is empty or all entities of this type has been removed
        updateDeleteIndex(entityType, entityList.size());
        return key;
    }

    private void updateDeleteIndex(final EntityType entityType, final int index) {
        switch (entityType) {
            case Crypto:
                cryptoDeleteIdx = index;
                break;
            case FCQ:
                fcqDeleteIdx = index;
                break;
            case VIRTUAL_MERKLE_ACCOUNT:
                virtualMerkleAccountDeleteIdx = index;
                break;
            default:
                throw new IllegalArgumentException("Unknown EntityType: " + entityType);
        }
    }

    /**
     * check if should handle the transaction
     *
     * @return Whether the transaction should be handled or not
     */
    public boolean shouldHandleForKeys(
            final List<MapKey> mapKeys,
            final TransactionType transactionType,
            final PayloadCfgSimple payloadCfgSimple,
            final EntityType entityType,
            final long epochMillis,
            final long originId) {
        for (MapKey mapKey : mapKeys) {
            if (!shouldHandle(mapKey, transactionType, payloadCfgSimple, entityType, epochMillis, originId)) {
                return false;
            }
        }
        return true;
    }

    /**
     * we don't handle a transaction in the following cases:
     * (1) the transaction tries to operate on an entity which does not exist in ExpectedMap;
     * (2) the entity's isErrored flag is true;
     * (3) the transaction tries to operate on an entity exists in ExpectedMap, but latestHandledStatus is null, which
     * means the entity doesn't exist in actual MerkleMap;
     * (4) the entity's latestHandledStatus is HANDLE_REJECTED;
     * (5) the transaction tries to create an existing entity;
     * (6) the transaction's entityType doesn't match the entity's entityType
     * (7) the entity has been removed, i.e., latestHandledStatus's transType is DELETE/EXPIRE
     *
     * @param mapKey
     * 		MapKey of the entity in the transaction
     * @param transactionType
     * 		type of transaction
     * @param payloadCfgSimple
     * 		config based on which we log an info or error when the transaction should not be handled
     * @param entityType
     * 		type of this entity
     * @param epochMillis
     * 		consensus time of this transaction
     * @param originId
     * 		id of the node which initializes this transaction
     * @return should handle this transaction or not
     */
    boolean shouldHandle(
            final MapKey mapKey,
            final TransactionType transactionType,
            final PayloadCfgSimple payloadCfgSimple,
            final EntityType entityType,
            final long epochMillis,
            final long originId) {
        ExpectedValue expectedValue = expectedMap.get(mapKey);

        // case 1:
        // when this entity doesn't exist, we only handle CREATE transaction;
        // otherwise we don't handle, and log an info/error
        if (expectedValue == null) {
            return checkPerformOnNonExistingEntities(
                    mapKey, transactionType, payloadCfgSimple, entityType, epochMillis, originId);
        }

        // case 2:
        // we don't handle any transactions for an entity with isErrored be true
        //		if (expectedValue.isErrored()) {
        //			return false;
        //		}

        // case 3:
        // if an ExpectedValue's latestHandledStatus is null, the entity is not in actual Map,
        // in this case, we only handle CREATE transaction;
        // otherwise we don't handle, and log an info/error
        if (expectedValue.getLatestHandledStatus() == null) {
            return checkPerformOnNonExistingEntities(
                    mapKey, transactionType, payloadCfgSimple, entityType, epochMillis, originId);
        }

        // case 4:
        // if isErrored is false, and handleRejected is true,
        // it denotes the entity has been deleted, and isPerformOnDeleted is true
        // we don't handle such transactions
        if (expectedValue.isHandleRejected()) {
            logger.info(
                    DEMO_TRANSACTION_INFO,
                    "Allowed PerformOnDeleted, " + "MapKey: {}, TransactionType: {}",
                    mapKey,
                    transactionType);
            return false;
        }

        // case 5:
        // if the transaction tries to create an existing entity, don't handle it
        if (creatingOnExistingEntities(expectedValue, mapKey, transactionType, payloadCfgSimple)) {
            return false;
        }

        // case 6:
        // if the transaction's entityType doesn't match the entity's entityType
        // don't handle it
        if (entityTypeMismatch(mapKey, transactionType, entityType, epochMillis, originId)) {
            return false;
        }

        // case 7:
        // we don't handle transactions performing on entity which has been removed
        return !performingOnRemoved(mapKey, transactionType, payloadCfgSimple, entityType, epochMillis, originId);
    }

    /**
     * when this entity doesn't exist, we only handle CREATE transaction;
     * for other TransactionTypes, we log an error when performOnNonExistingEntities is false
     *
     * @return should handle this transaction or not
     */
    private boolean checkPerformOnNonExistingEntities(
            final MapKey mapKey,
            final TransactionType transactionType,
            final PayloadCfgSimple payloadCfgSimple,
            final EntityType entityType,
            final long epochMillis,
            final long originId) {
        if (transactionType == Create) {
            return true;
        } else if (payloadCfgSimple != null && payloadCfgSimple.isPerformOnNonExistingEntities()) {
            logger.info(
                    DEMO_TRANSACTION_INFO,
                    "Allowed PerformOnNonExistingEntities, " + "MapKey: {}, TransactionType: {}",
                    mapKey,
                    transactionType);
            return false;
        } else {
            logger.error(
                    EXCEPTION.getMarker(),
                    "Error PerformOnNonExistingEntities, " + "MapKey: {}, TransactionType: {}",
                    mapKey,
                    transactionType);
            // put the entity to expectedMap;
            // set its ExpectedValues's isErrored to be true;
            // set its latestHandledStatus to be HANDLE_REJECTED
            setLatestHandledStatusForKey(
                    mapKey,
                    entityType,
                    null,
                    TransactionState.HANDLE_REJECTED,
                    transactionType,
                    epochMillis,
                    originId,
                    true);
            return false;
        }
    }

    /**
     * @return whether this transaction tries to create an existing entity
     */
    private boolean creatingOnExistingEntities(
            final ExpectedValue expectedValue,
            final MapKey mapKey,
            final TransactionType transactionType,
            final PayloadCfgSimple payloadCfgSimple) {
        if (transactionType == Create && expectedValue.getLatestHandledStatus() != null) {
            if (payloadCfgSimple != null && payloadCfgSimple.isCreateOnExistingEntities()) {
                logger.info(
                        DEMO_TRANSACTION_INFO,
                        "Allowed CreateOnExistingEntities, " + "MapKey: {}, TransactionType: {}, EntityType: {}",
                        mapKey,
                        transactionType,
                        expectedValue.getEntityType());
            } else {
                expectedValue.setErrored(true);
            }
            return true;
        }
        return false;
    }

    /**
     * Insert an entity by building expectedValue if the key doesn't exist in ExpectedMap
     * This might happen during reconnect, when a transaction is initialized, and before submitting to
     * network, node reconnects. After reconnect finishes, when transaction is submitted to network
     * and tries to modify submit  status, the key will not exist in expectedMap.
     * So add those entities to expectedMap, if they doesn't exist
     *
     * @param payload
     * 		payload of transaction that has missing entity
     * @param expectedFCMFamily
     * 		ExpectedFCMFamily
     * @param key
     * 		MapKey of the missing entity
     * @return true/false if the entity is inserted in ExpectedMap
     */
    public boolean insertMissingEntity(
            final byte[] payload,
            final ExpectedFCMFamily expectedFCMFamily,
            final MapKey key,
            final PayloadConfig payloadConfig) {
        TestTransaction trans = parseTransaction(payload, payloadConfig.isAppendSig());

        if (trans == null) {
            logger.error(
                    EXCEPTION.getMarker(),
                    "Error while parsing transaction, so could not insert entity with MapKey {} " + "to ExpectedMap",
                    key);
            return false;
        }

        final TransactionType transactionType = FCMTransactionUtils.getTransactionType(trans.getFcmTransaction());
        if (transactionType == TransactionType.TransferToken || transactionType == TransactionType.BurnToken) {
            return true;
        }

        // If mapkeys extracted from FCMTransaction and mapKey of entity that
        // is being inserted to expectedMap doesn't match return false
        final List<MapKey> mapKeys = FCMTransactionUtils.getMapKeys(trans.getFcmTransaction());
        if (!mapKeys.contains(key)) {
            // This should never happen because the key provided to modifySubmitStatus
            // is extracted from FCMTransaction
            logger.error(
                    EXCEPTION.getMarker(),
                    "MapKeys extracted from FCMTransaction {} and MapKey provided to "
                            + "modifySubmitStatus {} doesn't match ",
                    mapKeys,
                    key);
            return false;
        }

        // Check if the transaction is Create to add entity to Map
        if (transactionType != Create) {
            if (!payloadConfig.isPerformOnNonExistingEntities()) {
                logger.error(
                        EXCEPTION.getMarker(),
                        "performOnNonExistingEntities is not allowed and MapKey {} doesn't exist"
                                + " in ExpectedMap while modifyingSubmitStatus for transactionType {} ",
                        key,
                        transactionType);
            } else {
                logger.info(
                        DEMO_TRANSACTION_INFO,
                        "performOnNonExistingEntities is allowed and MapKey {} doesn't exist"
                                + " in ExpectedMap while modifyingSubmitStatus for transactionType {} ",
                        key,
                        transactionType);
            }
            return false;
        }
        // Extract originNodeId and EntityType from FCMTransaction to build entity's lifecycle status
        final long originNodeId = FCMTransactionUtils.getNodeId(trans.getFcmTransaction());
        final EntityType entityType = FCMTransactionUtils.getEntityType(trans.getFcmTransaction());
        final LifecycleStatus submitStatus = LifecycleStatus.builder()
                .setTransactionType(transactionType)
                .setTransactionState(INITIALIZED)
                .setTimestamp(Instant.now().getEpochSecond())
                .setNodeId(originNodeId)
                .build();

        expectedFCMFamily.getExpectedMap().put(key, new ExpectedValue(entityType, submitStatus));
        return true;
    }

    /**
     * Build LifecycleStatus from the transaction payload. This is used, if latestSubmitStatus is
     * missing for an entity, which might be caused because the entities are Rebuild after reconnect or restart
     *
     * @param payload
     * 		transaction payload to be parsed
     * @param payloadConfig
     * 		payloadConfig that has appendSig
     * @return lifecycleStatus that is built
     */
    public LifecycleStatus buildLifecycleStatusFromPayload(byte[] payload, PayloadConfig payloadConfig) {
        final TestTransaction trans = parseTransaction(payload, payloadConfig.isAppendSig());

        final long originNodeId = FCMTransactionUtils.getNodeId(trans.getFcmTransaction());
        final TransactionType transactionType = FCMTransactionUtils.getTransactionType(trans.getFcmTransaction());
        return LifecycleStatus.builder()
                .setTransactionType(transactionType)
                .setTransactionState(INITIALIZED)
                .setTimestamp(Instant.now().getEpochSecond())
                .setNodeId(originNodeId)
                .build();
    }

    /**
     * Parse the TestTransaction from payload bytes provided
     *
     * @param payload
     * 		transaction bytes from which TestTransaction should be parsed
     * @param isAppendSig
     * 		if AppendSig configuration is true/false in JSON config
     * @return TestTransaction that is parsed from the payload bytes
     */
    private TestTransaction parseTransaction(byte[] payload, boolean isAppendSig) {
        TestTransaction trans;
        byte[] payloadBytes;
        if (isAppendSig) {
            try {
                payloadBytes = TestTransactionWrapper.parseFrom(payload)
                        .getTestTransactionRawBytes()
                        .toByteArray();
            } catch (InvalidProtocolBufferException e) {
                logger.error(
                        EXCEPTION.getMarker(),
                        "Could not parsing TestTransactionWrapper with payload {}",
                        hex(payload),
                        e);
                return null;
            }
        } else {
            payloadBytes = payload;
        }

        try {
            trans = TestTransaction.parseFrom(payloadBytes);
        } catch (Exception e) {
            logger.error(EXCEPTION.getMarker(), "Could not parsing TestTransaction with payload {}", hex(payload), e);
            return null;
        }
        return trans;
    }

    /**
     * @return whether the transaction's entityType doesn't match the entity's entityType
     */
    private boolean entityTypeMismatch(
            final MapKey mapKey,
            final TransactionType transactionType,
            final EntityType entityType,
            final long epochMillis,
            final long originId) {
        // if the transaction's entityType doesn't match the entity's entityType
        // set the entity's latestHandledStatus to be HANDLE_ENTITY_TYPE_MISMATCH
        // log an error, and set isErrored to be true
        if (expectedMap.containsKey(mapKey) && !checkEntityType(mapKey, entityType)) {
            logger.error(
                    EXCEPTION.getMarker(),
                    "Entity type mismatch, " + "MapKey: {}, TransactionType: {}, originId: {}",
                    mapKey,
                    transactionType,
                    originId);
            setLatestHandledStatusForKey(
                    mapKey,
                    entityType,
                    null,
                    TransactionState.HANDLE_ENTITY_TYPE_MISMATCH,
                    transactionType,
                    epochMillis,
                    originId,
                    true);
            return true;
        }
        return false;
    }

    /**
     * @return whether the transaction is performing on entity which has been removed
     */
    private boolean performingOnRemoved(
            final MapKey mapKey,
            final TransactionType transactionType,
            final PayloadCfgSimple payloadCfgSimple,
            final EntityType entityType,
            final long epochMillis,
            final long originId) {
        // if this entity has been removed, i.e., latestHandledStatus's transType is DELETE/EXPIRE,
        // set new latestHandledStatus to be (HANDLE_REJECTED, transType, timestamp),
        // and log it an info if performOnDeleted is true,
        // or log an error and set IsErrored flag to true if performOnDeleted is false.
        if (entityHasBeenRemoved(mapKey)) {
            logDeleteInfo(mapKey, transactionType, payloadCfgSimple, entityType, epochMillis, originId);
            return true;
        }

        return false;
    }

    private void logDeleteInfo(
            final MapKey mapKey,
            final TransactionType transactionType,
            final PayloadCfgSimple payloadCfgSimple,
            final EntityType entityType,
            final long epochMillis,
            final long originId) {
        final boolean isError = payloadCfgSimple == null || !payloadCfgSimple.isPerformOnDeleted();
        if (isError) {
            logger.info(
                    PERFORM_ON_CREATE_DELETE,
                    "latestHandledStatus set to be HANDLE_REJECTED." + " ERROR PerformOnDeleted, "
                            + "MapKey: {}, TransactionType: {}, originId: {}",
                    mapKey,
                    transactionType,
                    originId);
        }

        setLatestHandledStatusForKey(
                mapKey,
                entityType,
                null,
                TransactionState.HANDLE_REJECTED,
                transactionType,
                epochMillis,
                originId,
                isError);
    }

    /**
     * set latestHandledStatus of ExpectedValue for mapKey:
     * add this entity to ExpectedMap if it is a new entity;
     * replace historyHandledStatus with current latestHandledStatus;
     * set latestHandledStatus to be new value
     */
    public void setLatestHandledStatusForKey(
            final MapKey mapKey,
            final EntityType entityType,
            final MapValue mapValue,
            final TransactionState state,
            final TransactionType transactionType,
            final long timestamp,
            final long nodeId,
            final boolean error) {
        final Hash newHash;
        try {
            newHash = mapValue == null ? null : mapValue.calculateHash();
            // create this entity in ExpectedMap if it doesn't exist
            ExpectedValue expectedValue = expectedMap.get(mapKey);
            boolean newEntity = false;

            if (expectedValue == null) {
                newEntity = true;
                expectedValue = new ExpectedValue(entityType, null);
                expectedValue.setUid(mapValue == null ? 0 : mapValue.getUid());
            }

            if (expectedValue.getUid() == 0 && mapValue != null) {
                expectedValue.setUid(mapValue.getUid());
            }

            if (newHash != null) {
                expectedValue.setHash(newHash);
                logger.trace(
                        EXPIRATION_MARKER,
                        "New Hash calculated after modifying latestHandledStatus {} for mapKey {}",
                        newHash,
                        mapKey);
            }

            expectedValue.setErrored(error);
            expectedValue.setHistoryHandledStatus(expectedValue.getLatestHandledStatus());
            expectedValue.setLatestHandledStatus(new LifecycleStatus(state, transactionType, timestamp, nodeId));
            if (newEntity) {
                addEntityToExpectedMap(mapKey, expectedValue);
            }
            if (state == TransactionState.HANDLED && (transactionType == Create || transactionType == Delete)) {
                updateEntityCounter(transactionType, entityType);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * check if an entity's latestHandledStatus's transType is: DELETE/EXPIRE
     *
     * @return whether the entity has been deleted/expired
     */
    public boolean entityHasBeenRemoved(final MapKey mapKey) {
        if (expectedMap == null || !expectedMap.containsKey(mapKey)) {
            return false;
        }
        LifecycleStatus latestHandledStatus = expectedMap.get(mapKey).getLatestHandledStatus();
        LifecycleStatus historyHandledStatus = expectedMap.get(mapKey).getHistoryHandledStatus();

        if (latestHandledStatus == null) {
            return false;
        }

        TransactionType latestHandledTxType = latestHandledStatus.getTransactionType();

        if (historyHandledStatus == null) {
            return latestHandledTxType == Delete || latestHandledTxType == Expire;
        } else {
            TransactionType historyHandledTxType = historyHandledStatus.getTransactionType();

            return latestHandledTxType == Delete
                    || latestHandledTxType == Expire
                    || historyHandledTxType == Delete
                    || historyHandledTxType == Expire;
        }
    }

    /**
     * check if an entity's latestHandledStatus's transType is: DELETE/EXPIRE
     * or latestSubmitStatus's transType is DELETE
     *
     * @return whether the entity has been or is to be deleted/expired
     */
    private boolean isRemovedEntity(final MapKey mapKey) {
        if (mapKey == null || !expectedMap.containsKey(mapKey)) {
            return false;
        }
        if (entityHasBeenRemoved(mapKey)) {
            return true;
        }
        LifecycleStatus latestSubmitStatus = expectedMap.get(mapKey).getLatestSubmitStatus();
        return latestSubmitStatus != null && latestSubmitStatus.getTransactionType() == Delete;
    }

    /**
     * check if EntityType extracted from FCMTransaction matches the entity's type in ExpectedMap
     * return true if matches, or the entity doesn't exist in ExpectedMap, i.e. this should be an CREATE
     * transaction;
     * return false if the entity exist and the type does not match
     */
    boolean checkEntityType(final MapKey key, final EntityType entityType) {
        // if the entity doesn't exist in ExpectedMap,
        // this should be an CREATE transaction
        if (expectedMap == null || !expectedMap.containsKey(key) || entityType == NFT) {
            return true;
        }

        return expectedMap.get(key).getEntityType().equals(entityType);
    }

    /**
     * rebuild ExpectedMap after reconnect/start from saved state
     */
    public void rebuildExpectedMap(final FCMFamily fcmFamily, final boolean isRestart, final long timestamp) {
        if (fcmFamily == null) {
            logger.error(EXCEPTION.getMarker(), "fail to rebuild ExpectedMap, fcmFamily is null");
            return;
        }
        // expectedMap should not be null
        if (this.expectedMap == null) {
            logger.error(EXCEPTION.getMarker(), "fail to rebuild ExpectedMap, ExpectedMap is null");
            return;
        }
        // Save old expectedMap to check during killNetworkReconnect if the transactions for delete or
        // create have already been submitted, to prevent resubmission that cause error
        HashMap<MapKey, ExpectedValue> expectedMapOld = new HashMap<>(expectedMap);

        // clear expectedMap and the lists; reset deleteIdx
        this.clear();

        // update entityCounter
        cryptoCounter = fcmFamily.getMap().size();
        fcqCounter = fcmFamily.getAccountFCQMap().size();

        // initialize expectedMap and entity lists, and set initial capacity
        initExpectedMapAndLists(isRestart);

        // put cryptos to expectedMap
        addEntitiesFromActualFCMs(fcmFamily, Crypto, isRestart, timestamp, expectedMapOld);

        // put fcqs to expectedMap
        addEntitiesFromActualFCMs(fcmFamily, EntityType.FCQ, isRestart, timestamp, expectedMapOld);
    }

    /**
     * generate ExpectedValue for entities of the same entityType in actualMap,
     * and put into ExpectedMap;
     * set hash to be Hash of actual MapValue;
     * set isErrored to be false;
     * set LatestHandledStatus to be: (RECONNECT_ORIGIN/RESTART_ORIGIN, transactionType:null, timestamp, -1).
     *
     * @param fcmFamily
     * 		FCMFamily which contains actual MerkleMaps
     * @param entityType
     * 		type of entities to be added to ExpectedMap
     * @param isRestart
     * 		true denotes restart; false denotes reconnect
     * @param timestamp
     * 		the lastConsensus timestamp passed by the reconnect/restart hook
     */
    @SuppressWarnings("unchecked")
    private void addEntitiesFromActualFCMs(
            final FCMFamily fcmFamily,
            final EntityType entityType,
            final boolean isRestart,
            final long timestamp,
            final Map<MapKey, ExpectedValue> expectedMapOld) {
        final Map<MapKey, ? extends MerkleNode> actualMap = fcmFamily.getActualMap(entityType);
        if (actualMap == null) {
            logger.error(
                    EXCEPTION.getMarker(), "fail to rebuild ExpectedMap for {} Entity, actualMap is null", entityType);
            return;
        }

        logger.info(DEMO_TRANSACTION_INFO, "type: {}, actualMap size: {}", entityType, actualMap.size());
        List<MapKey> entityList = getEntityList(entityType);
        List<MapKey> selfEntities = getSelfEntitiesList(entityType);

        TransactionState transactionState =
                isRestart ? TransactionState.RESTART_ORIGIN : TransactionState.RECONNECT_ORIGIN;
        // in LifecycleStatus, the nodeId denotes which node generates this transaction; since at restart/reconnect,
        // the LifcycleStatus is not modified by any transaction, we set nodeId to be -1;
        long nodeId = -1;

        for (Map.Entry<MapKey, ? extends MerkleNode> entry : actualMap.entrySet()) {
            final Hash hash = entry.getValue().getHash();

            final LifecycleStatus latestHandledStatus =
                    new LifecycleStatus(transactionState, Rebuild, timestamp, nodeId);

            final long uid = ((MapValue) entry.getValue()).getUid();

            ExpectedValue expectedValue =
                    new ExpectedValue(entityType, hash, false, null, latestHandledStatus, null, uid);
            final ExpectedValue oldValue = expectedMapOld.get(entry.getKey());

            // If it is reconnect and if Delete transaction is SUBMITTED/INITIALIZED to an entity before
            // reconnect, add the same old Value to expectedMap with Rebuild transactionType in latestHandledStatus
            if (!isRestart && isEntityDeleted(oldValue)) {
                expectedValue = expectedValue.setLatestSubmitStatus(oldValue.getLatestSubmitStatus());
            }
            addEntityToExpectedMap(entry.getKey(), expectedValue);
        }

        // If it is reconnect add entities that are created before reconnect which are INITIALIZED or SUBMITTED
        if (!isRestart) {
            addEntitiesCreated(expectedMapOld);
        }

        logRebuildingMsg(entityType, actualMap.size(), entityList.size(), selfEntities.size());
    }

    /**
     * Some entities might have just INITIALIZED/SUBMITTED Delete transaction, so that entity will still be in
     * state received from other node during reconnect.
     * Check if a delete transaction is submitted/initialized for a entity, to add them to ExpectedMap, with submit
     * status of oldValue
     *
     * @param oldValue
     * 		Value of the entity in old expectedMap before reconnect
     * @return true/false based on if the entity is deleted
     */
    boolean isEntityDeleted(ExpectedValue oldValue) {
        if (oldValue == null) {
            return false;
        }
        LifecycleStatus submitStatus = oldValue.getLatestSubmitStatus();
        return submitStatus != null
                && submitStatus.getTransactionType() != null
                && submitStatus.getTransactionType().equals(Delete)
                && submitStatus.getTransactionState() != null
                && !submitStatus.getTransactionState().equals(TransactionState.SUBMISSION_FAILED);
    }

    /**
     * Some entities might have just INITIALIZED/SUBMITTED Create transaction, so that entity will not be in
     * the state that is received from other node during reconnect. Add such kind of entities to new expectedMap,
     * by checking in old ExpectedMap before reconnect
     *
     * @param expectedMapOld
     * 		Old expectedMap before reconnect
     */
    void addEntitiesCreated(Map<MapKey, ExpectedValue> expectedMapOld) {
        List<MapKey> createdEntities = expectedMapOld.keySet().stream()
                .filter(e -> !this.expectedMap.containsKey(e) && isEntityCreated(expectedMapOld.get(e)))
                .collect(Collectors.toList());
        createdEntities.forEach(e -> addEntityToExpectedMap(e, expectedMapOld.get(e)));
    }

    /**
     * Some entities might be just INITIALIZED/SUBMITTED which will not be in the state that is received from
     * other node during reconnect. Check if an entity is created before reconnect by looking in the old expectedMap
     *
     * @param oldValue
     * 		Value of the entity in old expectedMap before reconnect
     * @return true/false based on if the entity is created
     */
    boolean isEntityCreated(ExpectedValue oldValue) {
        if (oldValue == null) {
            return false;
        }
        LifecycleStatus submitStatus = oldValue.getLatestSubmitStatus();
        LifecycleStatus handleStatus = oldValue.getLatestHandledStatus();
        return submitStatus != null
                && handleStatus == null
                && submitStatus.getTransactionType() != null
                && submitStatus.getTransactionType().equals(Create)
                && submitStatus.getTransactionState() != null
                && !submitStatus.getTransactionState().equals(TransactionState.SUBMISSION_FAILED);
    }

    /**
     * add a new Entity to ExpectedMap
     * this method might be called by two threads concurrently:
     * one for initializing transactions, the other for handling transactions
     */
    public void addEntityToExpectedMap(final MapKey mapKey, final ExpectedValue expectedValue) {
        EntityType entityType = expectedValue.getEntityType();
        List<MapKey> entityList = getEntityList(entityType);
        List<MapKey> selfEntities = getSelfEntitiesList(entityType);

        this.expectedMap.put(mapKey, expectedValue);
        entityList.add(mapKey);

        if (isSelfCreated(mapKey)) {
            selfEntities.add(mapKey);
        }
        if (mapKey.getAccountId() > largestInExpectedMap.get()) {
            largestInExpectedMap.set(mapKey.getAccountId());
        }
    }

    /**
     * node i creates MapKey(i, i, accountId),
     * check whether a mapKey is created by current node
     */
    private boolean isSelfCreated(final MapKey mapKey) {
        return mapKey.getShardId() == nodeId && mapKey.getRealmId() == nodeId;
    }

    List<MapKey> getEntityList(final EntityType entityType) {
        switch (entityType) {
            case Crypto:
                return this.accountList;
            case FCQ:
                return this.fcqList;
            case VIRTUAL_MERKLE_ACCOUNT:
                return this.virtualMerkleAccountList;
            default:
                throw new IllegalArgumentException("Unknown EntityType: " + entityType);
        }
    }

    List<MapKey> getSelfEntitiesList(final EntityType entityType) {
        switch (entityType) {
            case Crypto:
                return this.accountSelfEntitiesList;
            case FCQ:
                return this.fcqSelfEntitiesList;
            case VIRTUAL_MERKLE_ACCOUNT:
                return this.virtualMerkleAccountSelfEntitiesList;
            default:
                throw new IllegalArgumentException("Unknown EntityType: " + entityType);
        }
    }

    void logRebuildingMsg(
            final EntityType entityType,
            final int actualMapSize,
            final int entityListSize,
            final int selfEntitiesSize) {
        logger.info(
                DEMO_TRANSACTION_INFO,
                "Finish adding {}s to ExpectedMap, " + "actual MerkleMap size: {}, "
                        + "ExpectedFCMFamily's {}EntityList size: {}, SelfEntitiesList size: {}, "
                        + "ExpectedMap's size: {}",
                entityType,
                actualMapSize,
                entityType,
                entityListSize,
                selfEntitiesSize,
                expectedMap.size());
    }

    /**
     * clear ExpectedMap and all lists, reset deleteIdx
     */
    void clear() {
        this.expectedMap.clear();
        this.accountList.clear();
        this.fcqList.clear();
        this.virtualMerkleAccountList.clear();
        this.accountSelfEntitiesList.clear();
        this.fcqSelfEntitiesList.clear();
        this.virtualMerkleAccountSelfEntitiesList.clear();

        cryptoDeleteIdx = 0;
        fcqDeleteIdx = 0;
        virtualMerkleAccountDeleteIdx = 0;

        cryptoCounter = 0;
        fcqCounter = 0;
        virtualMerkleAccountCounter = 0;
        largestInExpectedMap = new AtomicLong(0);
    }

    /**
     * after handling create/delete transaction, update corresponding entityCounter
     *
     * @param transactionType
     * 		Transaction Type
     * @param entityType
     * 		Entity type
     */
    private void updateEntityCounter(final TransactionType transactionType, final EntityType entityType) {
        switch (entityType) {
            case Crypto:
                if (transactionType == Create) {
                    cryptoCounter++;
                } else if (transactionType == Delete) {
                    cryptoCounter--;
                }
                break;
            case FCQ:
                if (transactionType == Create) {
                    fcqCounter++;
                } else if (transactionType == Delete) {
                    fcqCounter--;
                }
                break;
            case VIRTUAL_MERKLE_ACCOUNT:
                if (transactionType == Create) {
                    virtualMerkleAccountCounter++;
                } else if (transactionType == Delete) {
                    virtualMerkleAccountCounter--;
                }
                break;
            default:
                throw new IllegalArgumentException("Unknown EntityType: " + entityType);
        }
    }

    /**
     * return expected number of entities with given type in actual MerkleMap
     *
     * @param entityType
     * 		Entity Type
     * @return Count of elements for specified type
     */
    private int getEntityCounter(final EntityType entityType) {
        switch (entityType) {
            case Crypto:
                return cryptoCounter;
            case FCQ:
                return fcqCounter;
            default:
                throw new IllegalArgumentException("Unknown EntityType: " + entityType);
        }
    }

    /**
     * initialize ExpectedMap and set initial capacity:
     * if FCMConfig is not null,
     * set ExpectedMap's initial capacity to be expected entity amount calculated from FCMConfig,
     * i.e., expected amount of create transactions to be handled by each node;
     * else use default value;
     *
     * if we are to rebuild ExpectedMap after restart, we should set their capacity to be:
     * expected entity amount calculated from FCMConfig +
     * entity amounts in actual maps loaded in signed state file;
     */
    private void initExpectedMap(final boolean isRestart) {
        int expectedMapCapacity = getExpectedMapInitCapacity();
        if (isRestart) {
            expectedMapCapacity += cryptoCounter + fcqCounter + virtualMerkleAccountCounter;
        }
        this.expectedMap = new ConcurrentHashMap<>(expectedMapCapacity);
        logger.info(DEMO_INFO, "Set ExpectedMap initial capacity to be: {}", expectedMapCapacity);
    }

    /**
     * initialize all EntityLists and selfEntityLists, and set initial capacity:
     * if FCMConfig is not null,
     * (1) set each EntityList's initial capacity to be expected amount of create transactions for
     * certain EntityType o be handled by each node;
     * (2) set each SelfEntityList's initial capacity to be expected amount of create transactions for
     * certain EntityType to be submitted by each node;
     *
     * if we are to rebuild EntityLists after restart, we should add actual entity amounts in actual maps
     */
    private void initEntityListCapacity(final EntityType entityType, final boolean isRestart) {
        String entityDescription;
        final int listCapacity;
        final int selfListCapacity;
        switch (entityType) {
            case Crypto:
                entityDescription = "account";
                listCapacity = getEntityListInitCapacity(Crypto) + (isRestart ? cryptoCounter : 0);
                this.accountList = Collections.synchronizedList(new ArrayList<>(listCapacity));

                selfListCapacity = calculateSelfListCapacity(listCapacity);
                this.accountSelfEntitiesList = Collections.synchronizedList(new ArrayList<>(selfListCapacity));
                break;
            case FCQ:
                entityDescription = "fcq";
                listCapacity = getEntityListInitCapacity(FCQ) + (isRestart ? fcqCounter : 0);
                this.fcqList = Collections.synchronizedList(new ArrayList<>(listCapacity));

                selfListCapacity = calculateSelfListCapacity(listCapacity);
                this.fcqSelfEntitiesList = Collections.synchronizedList(new ArrayList<>(selfListCapacity));
                break;
            case VIRTUAL_MERKLE_ACCOUNT:
                entityDescription = "virtual-merkle-account";
                listCapacity = getEntityListInitCapacity(VIRTUAL_MERKLE_ACCOUNT)
                        + (isRestart ? virtualMerkleAccountCounter : 0);
                this.virtualMerkleAccountList = Collections.synchronizedList(new ArrayList<>(listCapacity));

                selfListCapacity = calculateSelfListCapacity(listCapacity);
                this.virtualMerkleAccountSelfEntitiesList =
                        Collections.synchronizedList(new ArrayList<>(selfListCapacity));
                break;
            default:
                throw new IllegalArgumentException("Unknown EntityType: " + entityType);
        }
        logger.info(DEMO_INFO, "Set {}List initial capacity to be: {}", entityDescription, listCapacity);
        logger.info(
                DEMO_INFO, "Set {}SelfEntitiesList initial capacity to be: {}", entityDescription, selfListCapacity);
    }

    int calculateSelfListCapacity(final int listCapacity) {
        return (int) Math.ceil((double) listCapacity / Math.max(weightedNodeNum, 1));
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public MapKey getMapKeyForQuery(final EntityType entityType) throws IllegalArgumentException {
        final List<MapKey> entityList;
        switch (entityType) {
            case Crypto:
                entityList = accountList;
                break;
            case FCQ:
                entityList = fcqList;
                break;
            case VIRTUAL_MERKLE_ACCOUNT:
                entityList = virtualMerkleAccountList;
                break;
            default:
                throw new IllegalArgumentException("Unknown EntityType: " + entityType);
        }

        if (entityList.isEmpty()) {
            return new MapKey(0, 0, 0);
        } else {
            // get a random MapKey from the entityList of the given type
            return entityList.get(ThreadLocalRandom.current().nextInt(entityList.size()));
        }
    }
}
